(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)
(* Specification of the Semgrep CLI JSON output format using ATD
 * (see https://atd.readthedocs.io/en/latest/ for more information on ATD).
 * This file specifies for now mostly the JSON format of the 'semgrep scan'
 * command, the default command of semgrep.
 * For the definitions of the Semgrep input, see rule_schema_v1.yaml.
 *
 * This file has the _v1 suffix to explicitely represent the
 * version of this JSON format. If you need to extend this file, please
 * be careful because you may break consumers of this format (e.g., the
 * Semgrep playground or Semgrep App backend or external users of this JSON).
 * See https://atd.readthedocs.io/en/latest/atdgen-tutorial.html?highlight=json#smooth-protocol-upgrades
 * for more information on how to smoothly extend the types in this file.
 * Any backward incompatible changes should require to upgrade the major
 * version of Semgrep as this JSON output is part of the "API" of Semgrep
 * (any incompatible changes to the rule format should also require a major
 *  version upgrade). Hopefully, we will always be backward compatible.
 *
 * This file is translated in OCaml modules by atdgen. Look for the
 * corresponding Semgrep_output_v1_[tj].ml[i] generated files
 * under dune's _build/ folder. A few types below have the 'deriving show'
 * decorator because those types are reused in semgrep core data structures
 * and we make heavy use of 'deriving show' in OCaml to help debug things.
 *
 * This file is also translated in Python modules by atdpy.
 * For Python, a few types have the 'dataclass(frozen=True)' decorator
 * so that the class can be hashed and put in set. Indeed, with 'Frozen=True'
 * the class is immutable and dataclass can autogenerate a hash function for it.
 * 
 * Finally this file is translated in jsonschema/openapi spec by atdcat, and
 * in Typescript modules by atdts.
 *
 * history:
 *  - the types in this file were originally inferred from JSON_report.ml for
 *    use by spacegrep when it was separate from semgrep-core. It's now also
 *    useds in JSON_report.ml (now called Core_json_output.ml)
 *  - it was extended to not only support semgrep-core JSON output but also
 *    (py)semgrep CLI output!
 *  - it was then simplified with the osemgrep migration effort by
 *    removing gradually the semgrep-core JSON output.
 *
 * There are other important form of outputs which are not specified here:
 *  - The schema for the generic AST dump is in AST_generic_v1.atd
 *  - The parsing stats of semgrep-core -parsing_stats -json have its own
 *    Parsing_stats.atd
 *  - The semgrep metrics sent to https://metrics.semgrep.dev in
 *    semgrep_metrics.atd
 *)

(* escape hatch *)
type raw_json <ocaml module="Yojson.Basic" t="t"> = abstract

(*****************************************************************************)
(* Versioning *)
(*****************************************************************************)
type version <ocaml attr="deriving show"> = string (* e.g., "1.1.0" *)

(*****************************************************************************)
(* Location *)
(*****************************************************************************)
(* Note that there is no filename here like in 'location' below.
 * Upgrade note: "position_bis" was merged with "position".
 *)
type position
    <ocaml attr="deriving show">
    <python decorator="dataclass(frozen=True, order=True)"> = {
  line: int; (* starts from 1 *)
  col: int; (* starts from 1 *)
  (* Byte position from the beginning of the file, starts at 0.
   * OCaml code sets it correctly. Python code sets it to a dummy value (-1).
   *)
  offset: int;
}

(* File path.
 * TODO: could convert directly to Fpath.t for OCaml
 * TODO: could convert directly to Path class of pathlib library for Python
 *)
type fpath <ocaml attr="deriving show"> = string

(* a.k.a range *)
type location
     <ocaml attr="deriving show">
     <python decorator="dataclass(frozen=True)"> = {
  path: fpath (* source file *);
  start: position;
  end <ocaml name="end_">: position;
}

(*****************************************************************************)
(* Simple semgrep types *)
(*****************************************************************************)

(* e.g., "javascript.security.do-not-use-eval" *)
type rule_id
  <ocaml attr="deriving show">
  <python decorator="dataclass(frozen=True)"> = string

(* TODO? PRO can actually have "flavors" (see Engine_type.ml) *)
type engine_kind
     <ocaml attr="deriving show">
     <python decorator="dataclass(frozen=True)"> = [
  | OSS
  | PRO
]

type rule_id_and_engine_kind <python decorator="dataclass(frozen=True)"> = (rule_id * engine_kind)

(* for secrets *)
type validation_state
  <ocaml attr="deriving show">
  <python decorator="dataclass(frozen=True)"> = [
  | CONFIRMED_VALID
  | CONFIRMED_INVALID
  | VALIDATION_ERROR
  | NO_VALIDATOR
]

(*****************************************************************************)
(* Matches *)
(*****************************************************************************)

(* ----------------------------- *)
(* Core *)
(* ----------------------------- *)

(* EXPERIMENTAL: Do not rely on those internal types, they might disappear *)

(* TODO: now only core_match_extra differ, otherwise it's just like cli_match *)
type core_match <python decorator="dataclass(frozen=True)"> = {
  check_id: rule_id;
  inherit location;
  extra: core_match_extra;
}

(* TODO: try to make it as close as possible to 'cli_match_extra' below *)
type core_match_extra <python decorator="dataclass(frozen=True)"> = {
  ?message: string option; (* rule.message (?) *)
  metavars: metavars;
  ?dataflow_trace: match_dataflow_trace option;
  (* If present, semgrep-core was able to compute a string that should be
   * inserted in place of the text in the matched range in order to fix the
   * finding. *)
  ?rendered_fix: string option;
  engine_kind: engine_kind;
  (* If present indicates the status of postprocessor validation. This field
   * not being present should be equivalent to NO_VALIDATOR.
   * Added in semgrep 1.37.0 *)
  ?validation_state : validation_state option;
  (* Escape hatch to pass untyped info from semgrep-core to the semgrep output.
   * Useful for quick experiments, especially when combined with semgrep
   * --core-opts flag.
   *)
  ?extra_extra: raw_json option;
}

(* ----------------------------- *)
(* CLI *)
(* ----------------------------- *)

type cli_match = {
  check_id: rule_id;
  inherit location;
  extra: cli_match_extra;
}

type cli_match_extra = {
  (* TODO: inherit match_extra; but need ?metavars because of dependency_aware code *)
  ?metavars: metavars option;

  (* added by the CLI (see formatter/json.py) *)
  fingerprint: string;
  lines: string;

  (* fields coming from the rule *)
  message: string;
  metadata: raw_json;
  (* LATER: use a variant for severity *)
  severity: string;

  (* fields derived from the rule *)
  ?fix: string option;
  ?fix_regex: fix_regex option;

  (* extra fields *)
  ?is_ignored: bool option;
  (* EXPERIMENTAL: added by dependency_aware code *)
  ?sca_info: sca_info option;

  (* TODO: done with monkey patching right now in the Python code,
   * and seems to be used only when sending findings to the App.
   *)
  ?fixed_lines: string list option;

  (* EXPERIMENTAL: For now, present only for taint findings. May be extended to others
   * later on. *)
  ?dataflow_trace: match_dataflow_trace option;

  ?engine_kind: engine_kind option;

  (* If present indicates the status of postprocessor validation. This field
   * not being present should be equivalent to NO_VALIDATOR.
   * Added in semgrep 1.37.0 *)
  ?validation_state: validation_state option;

  (* EXPERIMENTAL: see core_match_extra.extra_extra *)
  ?extra_extra: raw_json option;
}

type fix_regex = {
  regex: string;
  replacement: string;
  ?count: int option;
}

(*****************************************************************************)
(* Metavariables *)
(*****************************************************************************)

(* Name/value map of the matched metavariables.
 * The leading '$' must be included in the metavariable name.
 * TODO: semgrep-core always return a metavars, but dependency_aware Python code
 * does not always generate a metavars
*)
type metavars = (string * metavar_value) list
  <json repr="object">
  <python repr="dict">
  <ts repr="map">

(* TODO: should just inherit location. Maybe it was optimized to not contain
 * the filename, which might be redundant with the information in core_match,
 * but with deep-semgrep a metavar could also refer to code in another file,
 * so simpler to generalize and 'inherit location'.
 *)
type metavar_value <python decorator="dataclass(frozen=True)"> = {
  (* for certain metavariable like $...ARGS, 'end' may be equal to 'start'
   * to represent an empty metavariable value. The rest of the Python
   * code (message metavariable substitution and autofix) works
   * without change for empty ranges (when end = start).
   *)
  start: position;
  end <ocaml name="end_">: position;
  abstract_content: string; (* value? *)
  ?propagated_value: svalue_value option;
}

type svalue_value <python decorator="dataclass(frozen=True)"> = {
  ?svalue_start: position option;
  ?svalue_end: position option;
  svalue_abstract_content: string; (* value? *)
}

(*****************************************************************************)
(* Match dataflow trace *)
(*****************************************************************************)

(* EXPERIMENTAL *)
type match_dataflow_trace <python decorator="dataclass(frozen=True)"> = {
  ?taint_source: match_call_trace option;
  (* Intermediate variables which are involved in the dataflow. For taint, this
   * explains how the taint flows from the source to the sink. *)
  ?intermediate_vars: match_intermediate_var list option;
  (* For now, omitting the taint sink, since it's redundant data except for
   * certain cases that only appear with DeepSemgrep. We can add it in later
   * without breaking consumers. *)
  ?taint_sink: match_call_trace option;
}

(* the string attached to the location is the actual text from the file
 * TODO: define a location_with_content type that can be reused.
 *)
type match_call_trace <python decorator="dataclass(frozen=True, order=True)"> = [
  | CliLoc of (location * string)
  | CliCall of ((location * string) * match_intermediate_var list * match_call_trace)
] <ocaml repr="classic">


(* EXPERIMENTAL *)
type match_intermediate_var <python decorator="dataclass(frozen=True)"> = {
  location: location;
  (* Unlike abstract_content, this is the actual text read from the
   * corresponding source file *)
  content: string;
  (* This type happens to be mostly the same as a location for now, but
   * it's split out because Iago has plans to extend this with more information
   * *)
}

(*****************************************************************************)
(* Errors *)
(*****************************************************************************)

(* ----------------------------- *)
(* Core *)
(* ----------------------------- *)
(* EXPERIMENTAL: Do not rely on those internal types, they might disappear *)

(* See Semgrep_error_code.ml *)
(* TODO: try to make it as close as possible to 'cli_error' above, possibly
 * extending cli_error with more fields (but those fields must be optional
 * to remain backward compatible
 *)
type core_error <python decorator="dataclass(frozen=True)"> = {
  ?rule_id: rule_id option;
  error_type: core_error_kind;
  severity: core_severity;
  location: location;
  message: string;
  ?details: string option;
  }

(* coupling: if you add a constructor here with arguments, you probably need to adjust
 * _error_type_string() in semgrep/.../error.py
 * TODO? move all those <json name="..."> in _error_type_string()
 *)
type core_error_kind
    <ocaml attr="deriving show">
    <python decorator="dataclass(frozen=True, order=True)"> = [
  (* File parsing related errors;
     coupling: if you add a target parse error then metrics for
     cli need to be updated. See cli/src/semgrep/parsing_data.py.
  *)
  | LexicalError <json name="Lexical error">
  | ParseError (* a.k.a SyntaxError *) <json name="Syntax error">
  | SpecifiedParseError <json name="Other syntax error">
  | AstBuilderError <json name="AST builder error">
  (* Pattern parsing related errors.
   * There are more precise info about the error in
   * Rule.invalid_rule_error_kind in Rule.ml.
   * TODO? should we move invalid_rule_error_kind here?
   *)
  | RuleParseError <json name="Rule parse error">
  (* the string list is the "YAML path" of the pattern, e.g. ["rules"; "1"; ...] *)
  | PatternParseError <json name="Pattern parse error"> of string list
  | InvalidYaml <json name="Invalid YAML">
  (* matching (semgrep) related *)
  | MatchingError (* internal error, e.g., NoTokenLocation *) <json name="Internal matching error">
  | SemgrepMatchFound (* TODO of string (* check_id *) *) <json name="Semgrep match found">
  | TooManyMatches <json name="Too many matches">
  (* other *)
  | FatalError (* missing file, OCaml errors, etc. *) <json name="Fatal error">
  | Timeout <json name="Timeout">
  | OutOfMemory <json name="Out of memory">
  (* pro-engine specific *)
  | TimeoutDuringInterfile <json name="Timeout during interfile analysis">
  | OutOfMemoryDuringInterfile <json name="OOM during interfile analysis">
  (* since semgrep 0.97 *)
  | PartialParsing of location list (* list of skipped tokens *)
  (* since semgrep 1.38.0 *)
  | IncompatibleRule of incompatible_rule
  (* since semgrep 1.40.0 *)
  | MissingPlugin
] <ocaml repr="classic">

type incompatible_rule
     <ocaml attr="deriving show">
     <python decorator="dataclass(frozen=True)"> = {
  rule_id: rule_id;
  this_version: version;
  ?min_version: version option;
  ?max_version: version option;
}

(*
   error = something wrong that must be fixed
   warning = something wrong that should be fixed
   info = some special condition worth knowing about
*)
type core_severity
    <ocaml attr="deriving show">
    <python decorator="dataclass(frozen=True)"> = [
  | Error <json name="error">
  | Warning <json name="warning">
  | Info <json name="info">
] <ocaml repr="classic">
 
(* ----------------------------- *)
(* CLI *)
(* ----------------------------- *)
(* (called SemgrepError in error.py) *)

type cli_error = {
  (* exit code? *)
  code: int;
  (* TODO: use a variant (Warning | Error | ...) *)
  level: string;
  (* TODO: use a variant that or inherit/extend core_error_kind
   * Right now we can't just use core_error_kind because SemgrepException
   * can also use self.__name__ for the type_, so we need to list
   * all the possible classes here (see error.py)
   *)
  type_ <json name="type">: string;

  (* LATER: use a variant instead of all those ?xxx types *)

  ?rule_id: rule_id option;

  (* for most parsing errors those are set *)
  ?message: string option; (* contains error location *)
  ?path: fpath option;

  (* for invalid rules, for ErrorWithSpan *)
  ?long_msg: string option;
  ?short_msg: string option;
  ?spans: error_span list option;
  ?help: string option;
}

type error_span = {
    (* for InvalidRuleSchemaError *)
    (* LATER: could inherit location; but file: vs path: *)
    (* TODO: source hash should probably also be mandatory? *)
    (* TODO: sometimes set to "<No file>" in rule_lang.py *)
    file: fpath;
    start: position;
    end <ocaml name="end_">: position;
    ?source_hash: string option;

    (*  The path to the pattern in the yaml rule
     *  and an adjusted start/end within just the pattern
     *  Used to report playground parse errors in the simple editor
     *  TODO: add an example because our source code doesn't make much sense.
     *
     *  TODO: remove this or add back simple editor error highlighting
     *)
    ?config_start: position nullable option;
    ?config_end: position nullable option;
    ?config_path: string list nullable option;

    (* LATER: what is this for? *)
    ?context_start: position nullable option;
    ?context_end: position nullable option;
  }

(*****************************************************************************)
(* Skipping information *)
(*****************************************************************************)

(* A reason for skipping a target file or a pair (target, rule).
 * Note that this type is also used in Report.ml hence the need
 * for deriving show here.
 *)
type skip_reason <ocaml attr="deriving show"> = [
  (* Originally returned by the Python CLI *)
  | Always_skipped <json name="always_skipped">
  | Semgrepignore_patterns_match <json name="semgrepignore_patterns_match">
  | Cli_include_flags_do_not_match <json name="cli_include_flags_do_not_match">
  | Cli_exclude_flags_match <json name="cli_exclude_flags_match">
  | Exceeded_size_limit <json name="exceeded_size_limit">
  | Analysis_failed_parser_or_internal_error
      <json name="analysis_failed_parser_or_internal_error">
  (* Originally returned by semgrep-core *)
  | Excluded_by_config <json name="excluded_by_config">
  | Wrong_language <json name="wrong_language">
  | Too_big <json name="too_big">
  | Minified <json name="minified">
  | Binary <json name="binary">
  | Irrelevant_rule <json name="irrelevant_rule">
  | Too_many_matches <json name="too_many_matches">
  (* New in osemgrep *)
  | Gitignore_patterns_match
  (* since 1.40.0 (dotfiles were always ignored, but not shown in the skip report *)
  | Dotfile
] <ocaml repr="classic">

(* coupling: ugly: with yield_json_objects() in target_manager.py *)
type skipped_target <ocaml attr="deriving show"> = {
  path: fpath;
  reason: skip_reason;
  (* since semgrep 1.39.0 (used to be return only by semgrep-core) *)
  ?details: string option;
  (* If the 'rule_id' field is missing, the target is assumed to have been
   * skipped for all the rules *)
  ?rule_id: rule_id option;
}

type scanned_and_skipped = {
    scanned: fpath list;
    (* really either _comment: (saying "you should use -v to get more info")
     * or skipped:. We should have used a variant.
     *)
    ?_comment: string option;
    (* TODO: needs fix in atdpy; see note tagged [X584759]
     * ~skipped: skipped_target list;
    *)
    ?skipped: skipped_target list option;
}

type skipped_rule = {
  rule_id: rule_id;
  details: string;
  (* position of the error in the rule file *)
  position: position;
}

(*****************************************************************************)
(* Stats *)
(*****************************************************************************)

(* ----------------------------- *)
(* Core *)
(* ----------------------------- *)
type core_stats = {
  okfiles: int;
  errorfiles: int;
}

(* ----------------------------- *)
(* CLI *)
(* ----------------------------- *)

(*****************************************************************************)
(* Profiling information *)
(*****************************************************************************)
(* coupling: with semgrep_metrics.atd performance section *)

(* ----------------------------- *)
(* Core *)
(* ----------------------------- *)

(* EXPERIMENTAL: Do not rely on those internal types, they might disappear *)

(* TODO: merge with profile below *)
type core_timing = {
  rules: rule_id list;

  rules_parse_time: float;

  targets: target_time list;
  (* TODO: total_bytes: int; *)

  ?max_memory_bytes : int option;
}

(* TODO: merge with cli_target_times *)
type target_time = {
  path: fpath;
  (* parse and match time for each rule on target *)
  rule_times: rule_times list;
  (* run time for all rules on target *)
  run_time: float;
}

type rule_times = {
  rule_id: rule_id;
  (* TODO: time to parse what? *)
  parse_time: float;
  match_time: float;
}

(* ----------------------------- *)
(* CLI *)
(* ----------------------------- *)
(* coupling: if you change the JSON schema below, you probably need to
 * also modify perf/run-benchmarks. Run locally  $ ./run-benchmarks --dummy --upload
 *)
type profile = {
    (* List of rules, including the one read but not run on any target.
     * This list is actually more an array which allows other
     * fields to reference rule by number instead of rule_id
     * (e.g., match_times further below) saving space in the JSON.
     *
     * Upgrade note: this used to be defined as a rule_id_dict where
     * each rule_id was inside a {id: rule_id} record (maybe so
     * we could have given more profiling info about each rule, but
     * this was never used, so better to make it simple).
     *)
    rules: rule_id list;

    (* LESS? could be part of profiling_times below instead *)
    rules_parse_time: float;
    (* coupling: semgrep_metrics.atd profilingTimes field?
     * LATER? define a cli_profiling_times with more precise keys? 
     * type cli_profiling_times <ocaml attr="deriving show"> = {
     *   config_time: float;
     *   core_time: float;
     *   ignores_time: float;
     *   total_time: float;
     *  }
     * LATER: get rid of profiler.dump_stats
     *)
    profiling_times: (string * float) list
      <json repr="object">
      <python repr="dict">
      <ts repr="map">;

    targets: cli_target_times list;
    total_bytes: int;

    (* maximum amount of memory used by Semgrep during its execution *)
    ?max_memory_bytes : int option;
  }

type cli_target_times = {
    path: fpath;
    num_bytes: int;
    (* each elt in the list refers to a rule in profile.rules *)
    match_times: float list;
    (* TODO: why a list? *)
    parse_times: float list;
    (* run time for all rules on target? *)
    run_time: float;
}

(*****************************************************************************)
(* Matching explanations *)
(*****************************************************************************)
(* coupling: semgrep-core/src/core/Matching_explanation.ml
 * LATER: merge with Matching_explanation.t at some point
 * EXPERIMENTAL *)
type matching_explanation = {
    op: matching_operation;
    children: matching_explanation list;
    (* result matches at this node (can be empty when we reach a nomatch) *)
    matches: core_match list;
    (* location in the rule file! not target file.
     * This tries to delimit the part of the rule relevant to the current
     * operation (e.g., the position of the 'patterns:' token in the rule
     * for the And operation).
     *)
    loc: location;
    }
(* TODO:
 * - Negation
 * - Where filters (metavar-comparison, etc)
 * - tainting source/sink/sanitizer
 * - subpattern EllipsisAndStmt, ClassHeaderAndElems
 * Note that this type is used in Matching_explanation.ml hence the need
 * for deriving show below.
 *)
type matching_operation <ocaml attr="deriving show { with_path = false}"> = [
  | And
  | Or
  | Inside
  (* XPat for eXtended pattern. Can be a spacegrep pattern, a
   * regexp pattern, or a proper semgrep pattern.
   * see semgrep-core/src/core/XPattern.ml
   *)
  | XPat of string
  (* TODO *)
  | Negation
  (* TODO "metavar-regex:xxx" | "metavar-comparison:xxx" | "metavar-pattern" *)
  | Filter of string
  (* TODO tainting "operations" *)
  | Taint
  | TaintSource
  | TaintSink
  | TaintSanitizer
  (* TODO subpatterns *)
  | EllipsisAndStmts
  | ClassHeaderAndElems
] <ocaml repr="classic">


(*****************************************************************************)
(* Final scan output  *)
(*****************************************************************************)

(* ----------------------------- *)
(* Core *)
(* ----------------------------- *)

(* EXPERIMENTAL: Do not rely on those internal types, they might disappear *)
type core_output = {

  (* errors are guaranteed to be duplicate free; see also Report.ml *)
  errors: core_error list;
  results: core_match list;

  inherit core_output_extra;
}

type core_output_extra = {  
  ?skipped_targets <json name="skipped">: skipped_target list option;
  ?time: core_timing option;
  ?explanations: matching_explanation list option;
  rules_by_engine: rule_id_and_engine_kind list;
  engine_requested: engine_kind;
  skipped_rules: skipped_rule list;

  stats: core_stats;
}

(* ----------------------------- *)
(* CLI *)
(* ----------------------------- *)

(* TODO: rename to scan_output at some point *)
type cli_output = {
    (* since: 0.92 *)
    ?version: version option;

    errors: cli_error list;
    results: cli_match list;

    inherit cli_output_extra;
}

(* TODO? used only in TEXT format:
 * ?color_output, per_finding_max_lines_limit, per_line_max_chars_limit
*)
type cli_output_extra = {
    (* targeting information *)
    paths: scanned_and_skipped;
    (* profiling information *)
    ?time: profile option;
    (* debugging (rule writing) information.
     * Note that as opposed to the dataflow trace, the explanations are not
     * embedded inside a match because we give also explanations when things are
     * not matching.
     * EXPERIMENTAL: since semgrep 0.109
     *)
    ?explanations: matching_explanation list option;

    (* These rules, classified by engine used, will let us be transparent in the CLI
     * output over what rules were run with what.
     * EXPERIMENTAL: since: 1.11.0
     *)
    ?rules_by_engine: rule_id_and_engine_kind list option;
    ?engine_requested: engine_kind option;

    (* EXPERIMENTAL: since: 1.37.0 *)
    ~skipped_rules: skipped_rule list;
}

(*****************************************************************************)
(* Semgrep Supply Chain (SSC) *)
(*****************************************************************************)
(* This is also known as Software Composition Analysis (SCA) *)

(* EXPERIMENTAL *)
type sca_info = {
  reachable: bool;
  reachability_rule: bool;
  sca_finding_schema: int;
  dependency_match: dependency_match;
}

type dependency_match = {
  dependency_pattern: dependency_pattern;
  found_dependency: found_dependency;
  lockfile: string;
}

(* both ecosystem and transitivity below have frozen=True so the generated
 * classes can be hashed and put in sets (see calls to reachable_deps.add()
 * in semgrep SCA code)
 *)
type ecosystem <python decorator="dataclass(frozen=True)"> = [
  | Npm <json name="npm">
  | Pypi  <json name="pypi">
  | Gem <json name="gem">
  | Gomod <json name="gomod">
  | Cargo <json name="cargo">
  | Maven <json name="maven">
  | Composer <json name="composer">
  | Nuget <json name="nuget">
]

type transitivity <python decorator="dataclass(frozen=True)"> = [
  | Direct <json name="direct">
  | Transitive <json name="transitive">
  | Unknown <json name="unknown">
]

type dependency_pattern = {
  ecosystem: ecosystem;
  package: string;
  semver_range: string;
}

type dependency_child = {
  package: string;
  version: string;
}

type found_dependency = {
  package: string;
  version: string;
  ecosystem: ecosystem;
  allowed_hashes: (string * string list) list
    <json repr="object">
    <python repr="dict">
    <ts repr="map">;
  ?resolved_url: string option;
  transitivity: transitivity;
  ?line_number: int option;
  (* store child dependency information for calculating path to transitivity*)
  ?children: dependency_child list option;
}

(* json names are to maintain backwards compatibility with the python enum it is replacing *)
type sca_parser_name = [
  | Gemfile_lock <json name="gemfile_lock">
  | Go_mod <json name="go_mod">
  | Go_sum <json name="go_sum">
  | Gradle_lockfile <json name="gradle_lockfile">
  | Gradle_build <json name="gradle_build">
  | Jsondoc <json name="jsondoc">
  | Pipfile <json name="pipfile">
  | Pnpm_lock <json name="pnpm_lock">
  | Poetry_lock <json name="poetry_lock">
  | Pyproject_toml <json name="pyproject_toml">
  | Requirements <json name="requirements">
  | Yarn_1 <json name="yarn_1">
  | Yarn_2 <json name="yarn_2">
  | Pomtree <json name="pomtree">
  | Cargo_parser <json name="cargo">
  | Composer_lock <json name="composer_lock">
]

type dependency_parser_error = {
  path: string;
  parser: sca_parser_name;
  reason: string;
  (* Not using `position` because this type must be backwards compatible with the python
   * class it is replacing.
   *)
  ?line: int option;
  ?col: int option;
  ?text: string option;
}


(*****************************************************************************)
(* Semgrep findings for the App *)
(*****************************************************************************)
(* TODO: see semgrep/app/scans.py
 * there is also api_scans_meta, api_scans_ignores, and api_scans_complete
 * EXPERIMENTAL
*)

(* ----------------------------- *)
(* CI scan results *)
(* ----------------------------- *)

(* Sent by the CLI to /findings_and_ignores (a.k.a. /results) *)
type ci_scan_results = {
  (* TODO: ?version: version option; *)
   findings: finding list;
   ignores: finding list;

   (* TODO? use a token type ? *)
   token: string nullable;

   (* TODO? use fpath ? *)
   searched_paths: string list;
   renamed_paths: string list;

   rule_ids: rule_id list;

   (* since semgrep 1.34.0 *)
   ?contributions: contributions option;
   (* since semgrep 1.38.0 *)
   (* this data was originally sent to /complete, but we want to start sending it /results *)
   ?dependencies: ci_scan_dependencies option;
}

(* See https://semgrep.dev/docs/usage-limits
 * coupling: this must match Git_wrapper.git_log_json_format
 *)
type contributor = {
    commit_author_name: string;
    commit_author_email: string;
}

type contribution = {
    commit_hash: string;
    commit_timestamp: string;
    contributor: contributor;
}

(* we keep this alias because we need to generate code to parse and write
 * list of contributions.
 *)
type contributions = contribution list

type ci_scan_dependencies = (string * found_dependency list) list
    <json repr="object">
    <python repr="dict">
    <ts repr="map">

(* ----------------------------- *)
(* CI scan complete response *)
(* ----------------------------- *)

(* Sent by the CLI to /complete *)
type ci_scan_complete_response = {
  exit_code: int;
  stats: ci_scan_complete_stats;
  ?dependencies: ci_scan_dependencies option;
  ?dependency_parser_errors: dependency_parser_error list option;
  ?task_id: string option;
}

type ci_scan_complete_stats = {
  findings: int;
  errors: cli_error list;
  total_time: float;

  unsupported_exts: (string * int) list
    <json repr="object">
    <python repr="dict">
    <ts repr="map">;
  lockfile_scan_info: (string * int) list
    <json repr="object">
    <python repr="dict">
    <ts repr="map">;
  parse_rate: (string * parsing_stats) list
    <json repr="object">
    <python repr="dict">
    <ts repr="map">;

  (* This is EngineType from python, which is different from engine_kind used in this file *)
  ?engine_requested: string option;
}

type parsing_stats = {
  targets_parsed: int;
  num_targets: int;
  bytes_parsed: int;
  num_bytes: int;
}

(* ----------------------------- *)
(* Findings *)
(* ----------------------------- *)

(* TODO: rewrite rule_matches.to_app_finding_format()
 * TODO: what's the endpoint? Where this is sent?
 *)
type finding = {
  check_id: rule_id;

  (* ugly: should reuse location instead of those 5 fields *)
  path: fpath;
  line: int;
  column: int;
  end_line: int;
  end_column: int;

  message: string;
  (* int|string until minimum version exceeds 1.32.0, then string *)
  severity: abstract;

  (* ?? *)
  index: int;

  commit_date: string;

  syntactic_id: string;
  (* since semgrep 0.98 *)
  ?match_based_id: string option;
  (* since semgrep 1.14.0 *)
  ?hashes: finding_hashes option;

  metadata: raw_json;

  (* ?? *)
  is_blocking: bool;

  ?fixed_lines: string list option;

  ?sca_info: sca_info option;
  ?dataflow_trace: match_dataflow_trace option;
  (* Added in semgrep 1.39.0 see comments in cli_match_extra. *)
  ?validation_state: validation_state option;
}

type finding_hashes = {
  start_line_hash: string;
  end_line_hash: string;
  (* hash of the syntactic_context/code contents from start_line through end_line *)
  code_hash: string;
  (* hash of the rule pattern with metavariables substituted in *)
  pattern_hash: string;
}
