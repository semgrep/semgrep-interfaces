/*
  Generated by atdts from type definitions in 'semgrep_output_v1.atd'.

  Type-safe translations from/to JSON

  For each type 'Foo', there is a pair of functions:
  - 'writeFoo': convert a 'Foo' value into a JSON-compatible value.
  - 'readFoo': convert a JSON-compatible value into a TypeScript value
    of type 'Foo'.
*/

/* tslint:disable */
/* eslint-disable */

export type RawJson = any

export type Version = string

export type Position = {
  line: number /*int*/;
  col: number /*int*/;
  offset: number /*int*/;
}

export type Fpath = string

export type Location = {
  path: Fpath;
  start: Position;
  end: Position;
}

export type RuleId = string

export type RuleIdAndEngineKind = [RuleId, EngineKind]

export type EngineKind =
| { kind: 'OSS' }
| { kind: 'PRO' }

export type ValidationState =
| { kind: 'CONFIRMED_VALID' }
| { kind: 'CONFIRMED_INVALID' }
| { kind: 'VALIDATION_ERROR' }
| { kind: 'NO_VALIDATOR' }

export type CoreMatch = {
  rule_id: RuleId;
  location: Location;
  extra: CoreMatchExtra;
}

export type CoreMatchExtra = {
  message?: string;
  metavars: Metavars;
  dataflow_trace?: CoreMatchDataflowTrace;
  rendered_fix?: string;
  engine_kind: EngineKind;
  validation_state?: ValidationState;
  extra_extra?: RawJson;
}

export type CoreMatchCallTrace =
| { kind: 'CoreLoc'; value: Location }
| { kind: 'CoreCall'; value: [Location, CoreMatchIntermediateVar[], CoreMatchCallTrace] }

export type CoreMatchDataflowTrace = {
  taint_source?: CoreMatchCallTrace;
  intermediate_vars?: CoreMatchIntermediateVar[];
  taint_sink?: CoreMatchCallTrace;
}

export type CoreMatchIntermediateVar = {
  location: Location;
}

export type Metavars = Map<string, MetavarValue>

export type MetavarValue = {
  start: Position;
  end: Position;
  abstract_content: string;
  propagated_value?: SvalueValue;
}

export type SvalueValue = {
  svalue_start?: Position;
  svalue_end?: Position;
  svalue_abstract_content: string;
}

export type CoreError = {
  rule_id?: RuleId;
  error_type: CoreErrorKind;
  severity: CoreSeverity;
  location: Location;
  message: string;
  details?: string;
}

export type CoreErrorKind =
| { kind: 'LexicalError' /* JSON: "Lexical error" */ }
| { kind: 'ParseError' /* JSON: "Syntax error" */ }
| { kind: 'SpecifiedParseError' /* JSON: "Other syntax error" */ }
| { kind: 'AstBuilderError' /* JSON: "AST builder error" */ }
| { kind: 'RuleParseError' /* JSON: "Rule parse error" */ }
| { kind: 'PatternParseError' /* JSON: "Pattern parse error" */; value: string[] }
| { kind: 'InvalidYaml' /* JSON: "Invalid YAML" */ }
| { kind: 'MatchingError' /* JSON: "Internal matching error" */ }
| { kind: 'SemgrepMatchFound' /* JSON: "Semgrep match found" */ }
| { kind: 'TooManyMatches' /* JSON: "Too many matches" */ }
| { kind: 'FatalError' /* JSON: "Fatal error" */ }
| { kind: 'Timeout' }
| { kind: 'OutOfMemory' /* JSON: "Out of memory" */ }
| { kind: 'TimeoutDuringInterfile' /* JSON: "Timeout during interfile analysis" */ }
| { kind: 'OutOfMemoryDuringInterfile' /* JSON: "OOM during interfile analysis" */ }
| { kind: 'PartialParsing'; value: Location[] }

export type CoreSeverity =
| { kind: 'Error' /* JSON: "error" */ }
| { kind: 'Warning' /* JSON: "warning" */ }

export type CoreStats = {
  okfiles: number /*int*/;
  errorfiles: number /*int*/;
}

export type SkippedTarget = {
  path: Fpath;
  reason: SkipReason;
  details: string;
  rule_id?: RuleId;
}

export type SkipReason =
| { kind: 'Gitignore_patterns_match' /* JSON: "gitignore_patterns_match" */ }
| { kind: 'Always_skipped' /* JSON: "always_skipped" */ }
| { kind: 'Semgrepignore_patterns_match' /* JSON: "semgrepignore_patterns_match" */ }
| { kind: 'Cli_include_flags_do_not_match' /* JSON: "cli_include_flags_do_not_match" */ }
| { kind: 'Cli_exclude_flags_match' /* JSON: "cli_exclude_flags_match" */ }
| { kind: 'Exceeded_size_limit' /* JSON: "exceeded_size_limit" */ }
| { kind: 'Analysis_failed_parser_or_internal_error' /* JSON: "analysis_failed_parser_or_internal_error" */ }
| { kind: 'Excluded_by_config' /* JSON: "excluded_by_config" */ }
| { kind: 'Wrong_language' /* JSON: "wrong_language" */ }
| { kind: 'Too_big' /* JSON: "too_big" */ }
| { kind: 'Minified' /* JSON: "minified" */ }
| { kind: 'Binary' /* JSON: "binary" */ }
| { kind: 'Irrelevant_rule' /* JSON: "irrelevant_rule" */ }
| { kind: 'Too_many_matches' /* JSON: "too_many_matches" */ }

export type SkippedRule = {
  rule_id: RuleId;
  details: string;
  position: Position;
}

export type CoreTiming = {
  targets: TargetTime[];
  rules: RuleId[];
  rules_parse_time?: number;
  max_memory_bytes: number /*int*/;
}

export type TargetTime = {
  path: Fpath;
  rule_times: RuleTimes[];
  run_time: number;
}

export type RuleTimes = {
  rule_id: RuleId;
  parse_time: number;
  match_time: number;
}

export type MatchingExplanation = {
  op: MatchingOperation;
  children: MatchingExplanation[];
  matches: CoreMatch[];
  loc: Location;
}

export type MatchingOperation =
| { kind: 'And' }
| { kind: 'Or' }
| { kind: 'Inside' }
| { kind: 'XPat'; value: string }
| { kind: 'Negation' }
| { kind: 'Filter'; value: string }
| { kind: 'Taint' }
| { kind: 'TaintSource' }
| { kind: 'TaintSink' }
| { kind: 'TaintSanitizer' }
| { kind: 'EllipsisAndStmts' }
| { kind: 'ClassHeaderAndElems' }

export type CveResult = {
  url: string;
  filename: string;
  funcnames: string[];
}

export type CveResults = CveResult[]

export type CoreMatchResults = {
  matches: CoreMatch[];
  errors: CoreError[];
  skipped_targets?: SkippedTarget[];
  skipped_rules?: SkippedRule[];
  explanations?: MatchingExplanation[];
  stats: CoreStats;
  time?: CoreTiming;
  rules_by_engine: RuleIdAndEngineKind[];
  engine_requested: EngineKind;
}

export type CliError = {
  code: number /*int*/;
  level: string;
  type_: string;
  rule_id?: RuleId;
  message?: string;
  path?: Fpath;
  long_msg?: string;
  short_msg?: string;
  spans?: ErrorSpan[];
  help?: string;
}

export type ErrorSpan = {
  file: Fpath;
  start: PositionBis;
  end: PositionBis;
  source_hash?: string;
  config_start?: (PositionBis | null);
  config_end?: (PositionBis | null);
  config_path?: (string[] | null);
  context_start?: (PositionBis | null);
  context_end?: (PositionBis | null);
}

export type PositionBis = {
  line: number /*int*/;
  col: number /*int*/;
}

export type CliMatchCallTrace =
| { kind: 'CliLoc'; value: [Location, string] }
| { kind: 'CliCall'; value: [[Location, string], CliMatchIntermediateVar[], CliMatchCallTrace] }

export type CliMatchDataflowTrace = {
  taint_source?: CliMatchCallTrace;
  intermediate_vars?: CliMatchIntermediateVar[];
  taint_sink?: CliMatchCallTrace;
}

export type CliMatchTaintSource = {
  location: Location;
  content: string;
}

export type CliMatchIntermediateVar = {
  location: Location;
  content: string;
}

export type CliMatch = {
  check_id: RuleId;
  path: Fpath;
  start: Position;
  end: Position;
  extra: CliMatchExtra;
}

export type CliMatchExtra = {
  metavars?: Metavars;
  fingerprint: string;
  lines: string;
  message: string;
  metadata: RawJson;
  severity: string;
  fix?: string;
  fix_regex?: FixRegex;
  is_ignored?: boolean;
  sca_info?: ScaInfo;
  fixed_lines?: string[];
  dataflow_trace?: CliMatchDataflowTrace;
  engine_kind?: EngineKind;
  validation_state?: ValidationState;
  extra_extra?: RawJson;
}

export type FixRegex = {
  regex: string;
  replacement: string;
  count?: number /*int*/;
}

export type CliOutput = {
  version?: Version;
  errors: CliError[];
  results: CliMatch[];
  paths: CliPaths;
  time?: CliTiming;
  explanations?: MatchingExplanation[];
  rules_by_engine?: RuleIdAndEngineKind[];
  engine_requested?: EngineKind;
}

export type CliOutputExtra = {
  paths: CliPaths;
  time?: CliTiming;
  explanations?: MatchingExplanation[];
  rules_by_engine?: RuleIdAndEngineKind[];
  engine_requested?: EngineKind;
}

export type CliPaths = {
  scanned: string[];
  _comment?: string;
  skipped?: CliSkippedTarget[];
}

export type CliSkippedTarget = {
  path: Fpath;
  reason: SkipReason;
}

export type CliTiming = {
  rules: RuleIdDict[];
  rules_parse_time: number;
  profiling_times: Map<string, number>;
  targets: CliTargetTimes[];
  total_bytes: number /*int*/;
  max_memory_bytes?: number /*int*/;
}

export type Contributor = {
  commit_author_name: string;
  commit_author_email: string;
}

export type Contribution = {
  commit_hash: string;
  commit_timestamp: string;
  contributor: Contributor;
}

export type Contributions = Contribution[]

export type RuleIdDict = {
  id: RuleId;
}

export type CliTargetTimes = {
  path: Fpath;
  num_bytes: number /*int*/;
  match_times: number[];
  parse_times: number[];
  run_time: number;
}

export type ScaInfo = {
  reachable: boolean;
  reachability_rule: boolean;
  sca_finding_schema: number /*int*/;
  dependency_match: DependencyMatch;
}

export type DependencyMatch = {
  dependency_pattern: DependencyPattern;
  found_dependency: FoundDependency;
  lockfile: string;
}

export type Ecosystem =
| { kind: 'Npm' /* JSON: "npm" */ }
| { kind: 'Pypi' /* JSON: "pypi" */ }
| { kind: 'Gem' /* JSON: "gem" */ }
| { kind: 'Gomod' /* JSON: "gomod" */ }
| { kind: 'Cargo' /* JSON: "cargo" */ }
| { kind: 'Maven' /* JSON: "maven" */ }
| { kind: 'Composer' /* JSON: "composer" */ }
| { kind: 'Nuget' /* JSON: "nuget" */ }

export type Transitivity =
| { kind: 'Direct' /* JSON: "direct" */ }
| { kind: 'Transitive' /* JSON: "transitive" */ }
| { kind: 'Unknown' /* JSON: "unknown" */ }

export type DependencyPattern = {
  ecosystem: Ecosystem;
  package_: string;
  semver_range: string;
}

export type DependencyChild = {
  package_: string;
  version: string;
}

export type FoundDependency = {
  package_: string;
  version: string;
  ecosystem: Ecosystem;
  allowed_hashes: Map<string, string[]>;
  resolved_url?: string;
  transitivity: Transitivity;
  line_number?: number /*int*/;
  children?: DependencyChild[];
}

export type ScaParserName =
| { kind: 'Gemfile_lock' /* JSON: "gemfile_lock" */ }
| { kind: 'Go_mod' /* JSON: "go_mod" */ }
| { kind: 'Go_sum' /* JSON: "go_sum" */ }
| { kind: 'Gradle_lockfile' /* JSON: "gradle_lockfile" */ }
| { kind: 'Gradle_build' /* JSON: "gradle_build" */ }
| { kind: 'Jsondoc' /* JSON: "jsondoc" */ }
| { kind: 'Pipfile' /* JSON: "pipfile" */ }
| { kind: 'Pnpm_lock' /* JSON: "pnpm_lock" */ }
| { kind: 'Poetry_lock' /* JSON: "poetry_lock" */ }
| { kind: 'Pyproject_toml' /* JSON: "pyproject_toml" */ }
| { kind: 'Requirements' /* JSON: "requirements" */ }
| { kind: 'Yarn_1' /* JSON: "yarn_1" */ }
| { kind: 'Yarn_2' /* JSON: "yarn_2" */ }
| { kind: 'Pomtree' /* JSON: "pomtree" */ }
| { kind: 'Cargo_parser' /* JSON: "cargo" */ }
| { kind: 'Composer_lock' /* JSON: "composer_lock" */ }

export type DependencyParserError = {
  path: string;
  parser: ScaParserName;
  reason: string;
  line?: number /*int*/;
  col?: number /*int*/;
  text?: string;
}

export type CiScanResults = {
  findings: Finding[];
  ignores: Finding[];
  token: (string | null);
  searched_paths: string[];
  renamed_paths: string[];
  rule_ids: string[];
  contributions?: Contributions;
  dependencies?: CiScanDependencies;
}

export type ParsingStats = {
  targets_parsed: number /*int*/;
  num_targets: number /*int*/;
  bytes_parsed: number /*int*/;
  num_bytes: number /*int*/;
}

export type CiScanCompleteStats = {
  findings: number /*int*/;
  errors: CliError[];
  total_time: number;
  unsupported_exts: Map<string, number /*int*/>;
  lockfile_scan_info: Map<string, number /*int*/>;
  parse_rate: Map<string, ParsingStats>;
  engine_requested?: string;
}

export type CiScanDependencies = Map<string, FoundDependency[]>

export type CiScanCompleteResponse = {
  exit_code: number /*int*/;
  stats: CiScanCompleteStats;
  dependencies?: CiScanDependencies;
  dependency_parser_errors?: DependencyParserError[];
  task_id?: string;
}

export type FindingHashes = {
  start_line_hash: string;
  end_line_hash: string;
  code_hash: string;
  pattern_hash: string;
}

export type Finding = {
  check_id: RuleId;
  path: Fpath;
  line: number /*int*/;
  column: number /*int*/;
  end_line: number /*int*/;
  end_column: number /*int*/;
  message: string;
  severity: any;
  index: number /*int*/;
  commit_date: string;
  syntactic_id: string;
  match_based_id?: string;
  hashes?: FindingHashes;
  metadata: RawJson;
  is_blocking: boolean;
  fixed_lines?: string[];
  sca_info?: ScaInfo;
  dataflow_trace?: CliMatchDataflowTrace;
}

export function writeRawJson(x: RawJson, context: any = x): any {
  return ((x: any, context): any => x)(x, context);
}

export function readRawJson(x: any, context: any = x): RawJson {
  return ((x: any, context): any => x)(x, context);
}

export function writeVersion(x: Version, context: any = x): any {
  return _atd_write_string(x, context);
}

export function readVersion(x: any, context: any = x): Version {
  return _atd_read_string(x, context);
}

export function writePosition(x: Position, context: any = x): any {
  return {
    'line': _atd_write_required_field('Position', 'line', _atd_write_int, x.line, x),
    'col': _atd_write_required_field('Position', 'col', _atd_write_int, x.col, x),
    'offset': _atd_write_required_field('Position', 'offset', _atd_write_int, x.offset, x),
  };
}

export function readPosition(x: any, context: any = x): Position {
  return {
    line: _atd_read_required_field('Position', 'line', _atd_read_int, x['line'], x),
    col: _atd_read_required_field('Position', 'col', _atd_read_int, x['col'], x),
    offset: _atd_read_required_field('Position', 'offset', _atd_read_int, x['offset'], x),
  };
}

export function writeFpath(x: Fpath, context: any = x): any {
  return _atd_write_string(x, context);
}

export function readFpath(x: any, context: any = x): Fpath {
  return _atd_read_string(x, context);
}

export function writeLocation(x: Location, context: any = x): any {
  return {
    'path': _atd_write_required_field('Location', 'path', writeFpath, x.path, x),
    'start': _atd_write_required_field('Location', 'start', writePosition, x.start, x),
    'end': _atd_write_required_field('Location', 'end', writePosition, x.end, x),
  };
}

export function readLocation(x: any, context: any = x): Location {
  return {
    path: _atd_read_required_field('Location', 'path', readFpath, x['path'], x),
    start: _atd_read_required_field('Location', 'start', readPosition, x['start'], x),
    end: _atd_read_required_field('Location', 'end', readPosition, x['end'], x),
  };
}

export function writeRuleId(x: RuleId, context: any = x): any {
  return _atd_write_string(x, context);
}

export function readRuleId(x: any, context: any = x): RuleId {
  return _atd_read_string(x, context);
}

export function writeRuleIdAndEngineKind(x: RuleIdAndEngineKind, context: any = x): any {
  return ((x, context) => [writeRuleId(x[0], x), writeEngineKind(x[1], x)])(x, context);
}

export function readRuleIdAndEngineKind(x: any, context: any = x): RuleIdAndEngineKind {
  return ((x, context): [RuleId, EngineKind] => { _atd_check_json_tuple(2, x, context); return [readRuleId(x[0], x), readEngineKind(x[1], x)] })(x, context);
}

export function writeEngineKind(x: EngineKind, context: any = x): any {
  switch (x.kind) {
    case 'OSS':
      return 'OSS'
    case 'PRO':
      return 'PRO'
  }
}

export function readEngineKind(x: any, context: any = x): EngineKind {
  switch (x) {
    case 'OSS':
      return { kind: 'OSS' }
    case 'PRO':
      return { kind: 'PRO' }
    default:
      _atd_bad_json('EngineKind', x, context)
      throw new Error('impossible')
  }
}

export function writeValidationState(x: ValidationState, context: any = x): any {
  switch (x.kind) {
    case 'CONFIRMED_VALID':
      return 'CONFIRMED_VALID'
    case 'CONFIRMED_INVALID':
      return 'CONFIRMED_INVALID'
    case 'VALIDATION_ERROR':
      return 'VALIDATION_ERROR'
    case 'NO_VALIDATOR':
      return 'NO_VALIDATOR'
  }
}

export function readValidationState(x: any, context: any = x): ValidationState {
  switch (x) {
    case 'CONFIRMED_VALID':
      return { kind: 'CONFIRMED_VALID' }
    case 'CONFIRMED_INVALID':
      return { kind: 'CONFIRMED_INVALID' }
    case 'VALIDATION_ERROR':
      return { kind: 'VALIDATION_ERROR' }
    case 'NO_VALIDATOR':
      return { kind: 'NO_VALIDATOR' }
    default:
      _atd_bad_json('ValidationState', x, context)
      throw new Error('impossible')
  }
}

export function writeCoreMatch(x: CoreMatch, context: any = x): any {
  return {
    'rule_id': _atd_write_required_field('CoreMatch', 'rule_id', writeRuleId, x.rule_id, x),
    'location': _atd_write_required_field('CoreMatch', 'location', writeLocation, x.location, x),
    'extra': _atd_write_required_field('CoreMatch', 'extra', writeCoreMatchExtra, x.extra, x),
  };
}

export function readCoreMatch(x: any, context: any = x): CoreMatch {
  return {
    rule_id: _atd_read_required_field('CoreMatch', 'rule_id', readRuleId, x['rule_id'], x),
    location: _atd_read_required_field('CoreMatch', 'location', readLocation, x['location'], x),
    extra: _atd_read_required_field('CoreMatch', 'extra', readCoreMatchExtra, x['extra'], x),
  };
}

export function writeCoreMatchExtra(x: CoreMatchExtra, context: any = x): any {
  return {
    'message': _atd_write_optional_field(_atd_write_string, x.message, x),
    'metavars': _atd_write_required_field('CoreMatchExtra', 'metavars', writeMetavars, x.metavars, x),
    'dataflow_trace': _atd_write_optional_field(writeCoreMatchDataflowTrace, x.dataflow_trace, x),
    'rendered_fix': _atd_write_optional_field(_atd_write_string, x.rendered_fix, x),
    'engine_kind': _atd_write_required_field('CoreMatchExtra', 'engine_kind', writeEngineKind, x.engine_kind, x),
    'validation_state': _atd_write_optional_field(writeValidationState, x.validation_state, x),
    'extra_extra': _atd_write_optional_field(writeRawJson, x.extra_extra, x),
  };
}

export function readCoreMatchExtra(x: any, context: any = x): CoreMatchExtra {
  return {
    message: _atd_read_optional_field(_atd_read_string, x['message'], x),
    metavars: _atd_read_required_field('CoreMatchExtra', 'metavars', readMetavars, x['metavars'], x),
    dataflow_trace: _atd_read_optional_field(readCoreMatchDataflowTrace, x['dataflow_trace'], x),
    rendered_fix: _atd_read_optional_field(_atd_read_string, x['rendered_fix'], x),
    engine_kind: _atd_read_required_field('CoreMatchExtra', 'engine_kind', readEngineKind, x['engine_kind'], x),
    validation_state: _atd_read_optional_field(readValidationState, x['validation_state'], x),
    extra_extra: _atd_read_optional_field(readRawJson, x['extra_extra'], x),
  };
}

export function writeCoreMatchCallTrace(x: CoreMatchCallTrace, context: any = x): any {
  switch (x.kind) {
    case 'CoreLoc':
      return ['CoreLoc', writeLocation(x.value, x)]
    case 'CoreCall':
      return ['CoreCall', ((x, context) => [writeLocation(x[0], x), _atd_write_array(writeCoreMatchIntermediateVar)(x[1], x), writeCoreMatchCallTrace(x[2], x)])(x.value, x)]
  }
}

export function readCoreMatchCallTrace(x: any, context: any = x): CoreMatchCallTrace {
  _atd_check_json_tuple(2, x, context)
  switch (x[0]) {
    case 'CoreLoc':
      return { kind: 'CoreLoc', value: readLocation(x[1], x) }
    case 'CoreCall':
      return { kind: 'CoreCall', value: ((x, context): [Location, CoreMatchIntermediateVar[], CoreMatchCallTrace] => { _atd_check_json_tuple(3, x, context); return [readLocation(x[0], x), _atd_read_array(readCoreMatchIntermediateVar)(x[1], x), readCoreMatchCallTrace(x[2], x)] })(x[1], x) }
    default:
      _atd_bad_json('CoreMatchCallTrace', x, context)
      throw new Error('impossible')
  }
}

export function writeCoreMatchDataflowTrace(x: CoreMatchDataflowTrace, context: any = x): any {
  return {
    'taint_source': _atd_write_optional_field(writeCoreMatchCallTrace, x.taint_source, x),
    'intermediate_vars': _atd_write_optional_field(_atd_write_array(writeCoreMatchIntermediateVar), x.intermediate_vars, x),
    'taint_sink': _atd_write_optional_field(writeCoreMatchCallTrace, x.taint_sink, x),
  };
}

export function readCoreMatchDataflowTrace(x: any, context: any = x): CoreMatchDataflowTrace {
  return {
    taint_source: _atd_read_optional_field(readCoreMatchCallTrace, x['taint_source'], x),
    intermediate_vars: _atd_read_optional_field(_atd_read_array(readCoreMatchIntermediateVar), x['intermediate_vars'], x),
    taint_sink: _atd_read_optional_field(readCoreMatchCallTrace, x['taint_sink'], x),
  };
}

export function writeCoreMatchIntermediateVar(x: CoreMatchIntermediateVar, context: any = x): any {
  return {
    'location': _atd_write_required_field('CoreMatchIntermediateVar', 'location', writeLocation, x.location, x),
  };
}

export function readCoreMatchIntermediateVar(x: any, context: any = x): CoreMatchIntermediateVar {
  return {
    location: _atd_read_required_field('CoreMatchIntermediateVar', 'location', readLocation, x['location'], x),
  };
}

export function writeMetavars(x: Metavars, context: any = x): any {
  return _atd_write_assoc_map_to_object(writeMetavarValue)(x, context);
}

export function readMetavars(x: any, context: any = x): Metavars {
  return _atd_read_assoc_object_into_map(readMetavarValue)(x, context);
}

export function writeMetavarValue(x: MetavarValue, context: any = x): any {
  return {
    'start': _atd_write_required_field('MetavarValue', 'start', writePosition, x.start, x),
    'end': _atd_write_required_field('MetavarValue', 'end', writePosition, x.end, x),
    'abstract_content': _atd_write_required_field('MetavarValue', 'abstract_content', _atd_write_string, x.abstract_content, x),
    'propagated_value': _atd_write_optional_field(writeSvalueValue, x.propagated_value, x),
  };
}

export function readMetavarValue(x: any, context: any = x): MetavarValue {
  return {
    start: _atd_read_required_field('MetavarValue', 'start', readPosition, x['start'], x),
    end: _atd_read_required_field('MetavarValue', 'end', readPosition, x['end'], x),
    abstract_content: _atd_read_required_field('MetavarValue', 'abstract_content', _atd_read_string, x['abstract_content'], x),
    propagated_value: _atd_read_optional_field(readSvalueValue, x['propagated_value'], x),
  };
}

export function writeSvalueValue(x: SvalueValue, context: any = x): any {
  return {
    'svalue_start': _atd_write_optional_field(writePosition, x.svalue_start, x),
    'svalue_end': _atd_write_optional_field(writePosition, x.svalue_end, x),
    'svalue_abstract_content': _atd_write_required_field('SvalueValue', 'svalue_abstract_content', _atd_write_string, x.svalue_abstract_content, x),
  };
}

export function readSvalueValue(x: any, context: any = x): SvalueValue {
  return {
    svalue_start: _atd_read_optional_field(readPosition, x['svalue_start'], x),
    svalue_end: _atd_read_optional_field(readPosition, x['svalue_end'], x),
    svalue_abstract_content: _atd_read_required_field('SvalueValue', 'svalue_abstract_content', _atd_read_string, x['svalue_abstract_content'], x),
  };
}

export function writeCoreError(x: CoreError, context: any = x): any {
  return {
    'rule_id': _atd_write_optional_field(writeRuleId, x.rule_id, x),
    'error_type': _atd_write_required_field('CoreError', 'error_type', writeCoreErrorKind, x.error_type, x),
    'severity': _atd_write_required_field('CoreError', 'severity', writeCoreSeverity, x.severity, x),
    'location': _atd_write_required_field('CoreError', 'location', writeLocation, x.location, x),
    'message': _atd_write_required_field('CoreError', 'message', _atd_write_string, x.message, x),
    'details': _atd_write_optional_field(_atd_write_string, x.details, x),
  };
}

export function readCoreError(x: any, context: any = x): CoreError {
  return {
    rule_id: _atd_read_optional_field(readRuleId, x['rule_id'], x),
    error_type: _atd_read_required_field('CoreError', 'error_type', readCoreErrorKind, x['error_type'], x),
    severity: _atd_read_required_field('CoreError', 'severity', readCoreSeverity, x['severity'], x),
    location: _atd_read_required_field('CoreError', 'location', readLocation, x['location'], x),
    message: _atd_read_required_field('CoreError', 'message', _atd_read_string, x['message'], x),
    details: _atd_read_optional_field(_atd_read_string, x['details'], x),
  };
}

export function writeCoreErrorKind(x: CoreErrorKind, context: any = x): any {
  switch (x.kind) {
    case 'LexicalError':
      return 'Lexical error'
    case 'ParseError':
      return 'Syntax error'
    case 'SpecifiedParseError':
      return 'Other syntax error'
    case 'AstBuilderError':
      return 'AST builder error'
    case 'RuleParseError':
      return 'Rule parse error'
    case 'PatternParseError':
      return ['Pattern parse error', _atd_write_array(_atd_write_string)(x.value, x)]
    case 'InvalidYaml':
      return 'Invalid YAML'
    case 'MatchingError':
      return 'Internal matching error'
    case 'SemgrepMatchFound':
      return 'Semgrep match found'
    case 'TooManyMatches':
      return 'Too many matches'
    case 'FatalError':
      return 'Fatal error'
    case 'Timeout':
      return 'Timeout'
    case 'OutOfMemory':
      return 'Out of memory'
    case 'TimeoutDuringInterfile':
      return 'Timeout during interfile analysis'
    case 'OutOfMemoryDuringInterfile':
      return 'OOM during interfile analysis'
    case 'PartialParsing':
      return ['PartialParsing', _atd_write_array(writeLocation)(x.value, x)]
  }
}

export function readCoreErrorKind(x: any, context: any = x): CoreErrorKind {
  if (typeof x === 'string') {
    switch (x) {
      case 'Lexical error':
        return { kind: 'LexicalError' }
      case 'Syntax error':
        return { kind: 'ParseError' }
      case 'Other syntax error':
        return { kind: 'SpecifiedParseError' }
      case 'AST builder error':
        return { kind: 'AstBuilderError' }
      case 'Rule parse error':
        return { kind: 'RuleParseError' }
      case 'Invalid YAML':
        return { kind: 'InvalidYaml' }
      case 'Internal matching error':
        return { kind: 'MatchingError' }
      case 'Semgrep match found':
        return { kind: 'SemgrepMatchFound' }
      case 'Too many matches':
        return { kind: 'TooManyMatches' }
      case 'Fatal error':
        return { kind: 'FatalError' }
      case 'Timeout':
        return { kind: 'Timeout' }
      case 'Out of memory':
        return { kind: 'OutOfMemory' }
      case 'Timeout during interfile analysis':
        return { kind: 'TimeoutDuringInterfile' }
      case 'OOM during interfile analysis':
        return { kind: 'OutOfMemoryDuringInterfile' }
      default:
        _atd_bad_json('CoreErrorKind', x, context)
        throw new Error('impossible')
    }
  }
  else {
    _atd_check_json_tuple(2, x, context)
    switch (x[0]) {
      case 'Pattern parse error':
        return { kind: 'PatternParseError', value: _atd_read_array(_atd_read_string)(x[1], x) }
      case 'PartialParsing':
        return { kind: 'PartialParsing', value: _atd_read_array(readLocation)(x[1], x) }
      default:
        _atd_bad_json('CoreErrorKind', x, context)
        throw new Error('impossible')
    }
  }
}

export function writeCoreSeverity(x: CoreSeverity, context: any = x): any {
  switch (x.kind) {
    case 'Error':
      return 'error'
    case 'Warning':
      return 'warning'
  }
}

export function readCoreSeverity(x: any, context: any = x): CoreSeverity {
  switch (x) {
    case 'error':
      return { kind: 'Error' }
    case 'warning':
      return { kind: 'Warning' }
    default:
      _atd_bad_json('CoreSeverity', x, context)
      throw new Error('impossible')
  }
}

export function writeCoreStats(x: CoreStats, context: any = x): any {
  return {
    'okfiles': _atd_write_required_field('CoreStats', 'okfiles', _atd_write_int, x.okfiles, x),
    'errorfiles': _atd_write_required_field('CoreStats', 'errorfiles', _atd_write_int, x.errorfiles, x),
  };
}

export function readCoreStats(x: any, context: any = x): CoreStats {
  return {
    okfiles: _atd_read_required_field('CoreStats', 'okfiles', _atd_read_int, x['okfiles'], x),
    errorfiles: _atd_read_required_field('CoreStats', 'errorfiles', _atd_read_int, x['errorfiles'], x),
  };
}

export function writeSkippedTarget(x: SkippedTarget, context: any = x): any {
  return {
    'path': _atd_write_required_field('SkippedTarget', 'path', writeFpath, x.path, x),
    'reason': _atd_write_required_field('SkippedTarget', 'reason', writeSkipReason, x.reason, x),
    'details': _atd_write_required_field('SkippedTarget', 'details', _atd_write_string, x.details, x),
    'rule_id': _atd_write_optional_field(writeRuleId, x.rule_id, x),
  };
}

export function readSkippedTarget(x: any, context: any = x): SkippedTarget {
  return {
    path: _atd_read_required_field('SkippedTarget', 'path', readFpath, x['path'], x),
    reason: _atd_read_required_field('SkippedTarget', 'reason', readSkipReason, x['reason'], x),
    details: _atd_read_required_field('SkippedTarget', 'details', _atd_read_string, x['details'], x),
    rule_id: _atd_read_optional_field(readRuleId, x['rule_id'], x),
  };
}

export function writeSkipReason(x: SkipReason, context: any = x): any {
  switch (x.kind) {
    case 'Gitignore_patterns_match':
      return 'gitignore_patterns_match'
    case 'Always_skipped':
      return 'always_skipped'
    case 'Semgrepignore_patterns_match':
      return 'semgrepignore_patterns_match'
    case 'Cli_include_flags_do_not_match':
      return 'cli_include_flags_do_not_match'
    case 'Cli_exclude_flags_match':
      return 'cli_exclude_flags_match'
    case 'Exceeded_size_limit':
      return 'exceeded_size_limit'
    case 'Analysis_failed_parser_or_internal_error':
      return 'analysis_failed_parser_or_internal_error'
    case 'Excluded_by_config':
      return 'excluded_by_config'
    case 'Wrong_language':
      return 'wrong_language'
    case 'Too_big':
      return 'too_big'
    case 'Minified':
      return 'minified'
    case 'Binary':
      return 'binary'
    case 'Irrelevant_rule':
      return 'irrelevant_rule'
    case 'Too_many_matches':
      return 'too_many_matches'
  }
}

export function readSkipReason(x: any, context: any = x): SkipReason {
  switch (x) {
    case 'gitignore_patterns_match':
      return { kind: 'Gitignore_patterns_match' }
    case 'always_skipped':
      return { kind: 'Always_skipped' }
    case 'semgrepignore_patterns_match':
      return { kind: 'Semgrepignore_patterns_match' }
    case 'cli_include_flags_do_not_match':
      return { kind: 'Cli_include_flags_do_not_match' }
    case 'cli_exclude_flags_match':
      return { kind: 'Cli_exclude_flags_match' }
    case 'exceeded_size_limit':
      return { kind: 'Exceeded_size_limit' }
    case 'analysis_failed_parser_or_internal_error':
      return { kind: 'Analysis_failed_parser_or_internal_error' }
    case 'excluded_by_config':
      return { kind: 'Excluded_by_config' }
    case 'wrong_language':
      return { kind: 'Wrong_language' }
    case 'too_big':
      return { kind: 'Too_big' }
    case 'minified':
      return { kind: 'Minified' }
    case 'binary':
      return { kind: 'Binary' }
    case 'irrelevant_rule':
      return { kind: 'Irrelevant_rule' }
    case 'too_many_matches':
      return { kind: 'Too_many_matches' }
    default:
      _atd_bad_json('SkipReason', x, context)
      throw new Error('impossible')
  }
}

export function writeSkippedRule(x: SkippedRule, context: any = x): any {
  return {
    'rule_id': _atd_write_required_field('SkippedRule', 'rule_id', writeRuleId, x.rule_id, x),
    'details': _atd_write_required_field('SkippedRule', 'details', _atd_write_string, x.details, x),
    'position': _atd_write_required_field('SkippedRule', 'position', writePosition, x.position, x),
  };
}

export function readSkippedRule(x: any, context: any = x): SkippedRule {
  return {
    rule_id: _atd_read_required_field('SkippedRule', 'rule_id', readRuleId, x['rule_id'], x),
    details: _atd_read_required_field('SkippedRule', 'details', _atd_read_string, x['details'], x),
    position: _atd_read_required_field('SkippedRule', 'position', readPosition, x['position'], x),
  };
}

export function writeCoreTiming(x: CoreTiming, context: any = x): any {
  return {
    'targets': _atd_write_required_field('CoreTiming', 'targets', _atd_write_array(writeTargetTime), x.targets, x),
    'rules': _atd_write_required_field('CoreTiming', 'rules', _atd_write_array(writeRuleId), x.rules, x),
    'rules_parse_time': _atd_write_optional_field(_atd_write_float, x.rules_parse_time, x),
    'max_memory_bytes': _atd_write_required_field('CoreTiming', 'max_memory_bytes', _atd_write_int, x.max_memory_bytes, x),
  };
}

export function readCoreTiming(x: any, context: any = x): CoreTiming {
  return {
    targets: _atd_read_required_field('CoreTiming', 'targets', _atd_read_array(readTargetTime), x['targets'], x),
    rules: _atd_read_required_field('CoreTiming', 'rules', _atd_read_array(readRuleId), x['rules'], x),
    rules_parse_time: _atd_read_optional_field(_atd_read_float, x['rules_parse_time'], x),
    max_memory_bytes: _atd_read_required_field('CoreTiming', 'max_memory_bytes', _atd_read_int, x['max_memory_bytes'], x),
  };
}

export function writeTargetTime(x: TargetTime, context: any = x): any {
  return {
    'path': _atd_write_required_field('TargetTime', 'path', writeFpath, x.path, x),
    'rule_times': _atd_write_required_field('TargetTime', 'rule_times', _atd_write_array(writeRuleTimes), x.rule_times, x),
    'run_time': _atd_write_required_field('TargetTime', 'run_time', _atd_write_float, x.run_time, x),
  };
}

export function readTargetTime(x: any, context: any = x): TargetTime {
  return {
    path: _atd_read_required_field('TargetTime', 'path', readFpath, x['path'], x),
    rule_times: _atd_read_required_field('TargetTime', 'rule_times', _atd_read_array(readRuleTimes), x['rule_times'], x),
    run_time: _atd_read_required_field('TargetTime', 'run_time', _atd_read_float, x['run_time'], x),
  };
}

export function writeRuleTimes(x: RuleTimes, context: any = x): any {
  return {
    'rule_id': _atd_write_required_field('RuleTimes', 'rule_id', writeRuleId, x.rule_id, x),
    'parse_time': _atd_write_required_field('RuleTimes', 'parse_time', _atd_write_float, x.parse_time, x),
    'match_time': _atd_write_required_field('RuleTimes', 'match_time', _atd_write_float, x.match_time, x),
  };
}

export function readRuleTimes(x: any, context: any = x): RuleTimes {
  return {
    rule_id: _atd_read_required_field('RuleTimes', 'rule_id', readRuleId, x['rule_id'], x),
    parse_time: _atd_read_required_field('RuleTimes', 'parse_time', _atd_read_float, x['parse_time'], x),
    match_time: _atd_read_required_field('RuleTimes', 'match_time', _atd_read_float, x['match_time'], x),
  };
}

export function writeMatchingExplanation(x: MatchingExplanation, context: any = x): any {
  return {
    'op': _atd_write_required_field('MatchingExplanation', 'op', writeMatchingOperation, x.op, x),
    'children': _atd_write_required_field('MatchingExplanation', 'children', _atd_write_array(writeMatchingExplanation), x.children, x),
    'matches': _atd_write_required_field('MatchingExplanation', 'matches', _atd_write_array(writeCoreMatch), x.matches, x),
    'loc': _atd_write_required_field('MatchingExplanation', 'loc', writeLocation, x.loc, x),
  };
}

export function readMatchingExplanation(x: any, context: any = x): MatchingExplanation {
  return {
    op: _atd_read_required_field('MatchingExplanation', 'op', readMatchingOperation, x['op'], x),
    children: _atd_read_required_field('MatchingExplanation', 'children', _atd_read_array(readMatchingExplanation), x['children'], x),
    matches: _atd_read_required_field('MatchingExplanation', 'matches', _atd_read_array(readCoreMatch), x['matches'], x),
    loc: _atd_read_required_field('MatchingExplanation', 'loc', readLocation, x['loc'], x),
  };
}

export function writeMatchingOperation(x: MatchingOperation, context: any = x): any {
  switch (x.kind) {
    case 'And':
      return 'And'
    case 'Or':
      return 'Or'
    case 'Inside':
      return 'Inside'
    case 'XPat':
      return ['XPat', _atd_write_string(x.value, x)]
    case 'Negation':
      return 'Negation'
    case 'Filter':
      return ['Filter', _atd_write_string(x.value, x)]
    case 'Taint':
      return 'Taint'
    case 'TaintSource':
      return 'TaintSource'
    case 'TaintSink':
      return 'TaintSink'
    case 'TaintSanitizer':
      return 'TaintSanitizer'
    case 'EllipsisAndStmts':
      return 'EllipsisAndStmts'
    case 'ClassHeaderAndElems':
      return 'ClassHeaderAndElems'
  }
}

export function readMatchingOperation(x: any, context: any = x): MatchingOperation {
  if (typeof x === 'string') {
    switch (x) {
      case 'And':
        return { kind: 'And' }
      case 'Or':
        return { kind: 'Or' }
      case 'Inside':
        return { kind: 'Inside' }
      case 'Negation':
        return { kind: 'Negation' }
      case 'Taint':
        return { kind: 'Taint' }
      case 'TaintSource':
        return { kind: 'TaintSource' }
      case 'TaintSink':
        return { kind: 'TaintSink' }
      case 'TaintSanitizer':
        return { kind: 'TaintSanitizer' }
      case 'EllipsisAndStmts':
        return { kind: 'EllipsisAndStmts' }
      case 'ClassHeaderAndElems':
        return { kind: 'ClassHeaderAndElems' }
      default:
        _atd_bad_json('MatchingOperation', x, context)
        throw new Error('impossible')
    }
  }
  else {
    _atd_check_json_tuple(2, x, context)
    switch (x[0]) {
      case 'XPat':
        return { kind: 'XPat', value: _atd_read_string(x[1], x) }
      case 'Filter':
        return { kind: 'Filter', value: _atd_read_string(x[1], x) }
      default:
        _atd_bad_json('MatchingOperation', x, context)
        throw new Error('impossible')
    }
  }
}

export function writeCveResult(x: CveResult, context: any = x): any {
  return {
    'url': _atd_write_required_field('CveResult', 'url', _atd_write_string, x.url, x),
    'filename': _atd_write_required_field('CveResult', 'filename', _atd_write_string, x.filename, x),
    'funcnames': _atd_write_required_field('CveResult', 'funcnames', _atd_write_array(_atd_write_string), x.funcnames, x),
  };
}

export function readCveResult(x: any, context: any = x): CveResult {
  return {
    url: _atd_read_required_field('CveResult', 'url', _atd_read_string, x['url'], x),
    filename: _atd_read_required_field('CveResult', 'filename', _atd_read_string, x['filename'], x),
    funcnames: _atd_read_required_field('CveResult', 'funcnames', _atd_read_array(_atd_read_string), x['funcnames'], x),
  };
}

export function writeCveResults(x: CveResults, context: any = x): any {
  return _atd_write_array(writeCveResult)(x, context);
}

export function readCveResults(x: any, context: any = x): CveResults {
  return _atd_read_array(readCveResult)(x, context);
}

export function writeCoreMatchResults(x: CoreMatchResults, context: any = x): any {
  return {
    'matches': _atd_write_required_field('CoreMatchResults', 'matches', _atd_write_array(writeCoreMatch), x.matches, x),
    'errors': _atd_write_required_field('CoreMatchResults', 'errors', _atd_write_array(writeCoreError), x.errors, x),
    'skipped': _atd_write_optional_field(_atd_write_array(writeSkippedTarget), x.skipped_targets, x),
    'skipped_rules': _atd_write_optional_field(_atd_write_array(writeSkippedRule), x.skipped_rules, x),
    'explanations': _atd_write_optional_field(_atd_write_array(writeMatchingExplanation), x.explanations, x),
    'stats': _atd_write_required_field('CoreMatchResults', 'stats', writeCoreStats, x.stats, x),
    'time': _atd_write_optional_field(writeCoreTiming, x.time, x),
    'rules_by_engine': _atd_write_required_field('CoreMatchResults', 'rules_by_engine', _atd_write_array(writeRuleIdAndEngineKind), x.rules_by_engine, x),
    'engine_requested': _atd_write_required_field('CoreMatchResults', 'engine_requested', writeEngineKind, x.engine_requested, x),
  };
}

export function readCoreMatchResults(x: any, context: any = x): CoreMatchResults {
  return {
    matches: _atd_read_required_field('CoreMatchResults', 'matches', _atd_read_array(readCoreMatch), x['matches'], x),
    errors: _atd_read_required_field('CoreMatchResults', 'errors', _atd_read_array(readCoreError), x['errors'], x),
    skipped_targets: _atd_read_optional_field(_atd_read_array(readSkippedTarget), x['skipped'], x),
    skipped_rules: _atd_read_optional_field(_atd_read_array(readSkippedRule), x['skipped_rules'], x),
    explanations: _atd_read_optional_field(_atd_read_array(readMatchingExplanation), x['explanations'], x),
    stats: _atd_read_required_field('CoreMatchResults', 'stats', readCoreStats, x['stats'], x),
    time: _atd_read_optional_field(readCoreTiming, x['time'], x),
    rules_by_engine: _atd_read_required_field('CoreMatchResults', 'rules_by_engine', _atd_read_array(readRuleIdAndEngineKind), x['rules_by_engine'], x),
    engine_requested: _atd_read_required_field('CoreMatchResults', 'engine_requested', readEngineKind, x['engine_requested'], x),
  };
}

export function writeCliError(x: CliError, context: any = x): any {
  return {
    'code': _atd_write_required_field('CliError', 'code', _atd_write_int, x.code, x),
    'level': _atd_write_required_field('CliError', 'level', _atd_write_string, x.level, x),
    'type': _atd_write_required_field('CliError', 'type_', _atd_write_string, x.type_, x),
    'rule_id': _atd_write_optional_field(writeRuleId, x.rule_id, x),
    'message': _atd_write_optional_field(_atd_write_string, x.message, x),
    'path': _atd_write_optional_field(writeFpath, x.path, x),
    'long_msg': _atd_write_optional_field(_atd_write_string, x.long_msg, x),
    'short_msg': _atd_write_optional_field(_atd_write_string, x.short_msg, x),
    'spans': _atd_write_optional_field(_atd_write_array(writeErrorSpan), x.spans, x),
    'help': _atd_write_optional_field(_atd_write_string, x.help, x),
  };
}

export function readCliError(x: any, context: any = x): CliError {
  return {
    code: _atd_read_required_field('CliError', 'code', _atd_read_int, x['code'], x),
    level: _atd_read_required_field('CliError', 'level', _atd_read_string, x['level'], x),
    type_: _atd_read_required_field('CliError', 'type', _atd_read_string, x['type'], x),
    rule_id: _atd_read_optional_field(readRuleId, x['rule_id'], x),
    message: _atd_read_optional_field(_atd_read_string, x['message'], x),
    path: _atd_read_optional_field(readFpath, x['path'], x),
    long_msg: _atd_read_optional_field(_atd_read_string, x['long_msg'], x),
    short_msg: _atd_read_optional_field(_atd_read_string, x['short_msg'], x),
    spans: _atd_read_optional_field(_atd_read_array(readErrorSpan), x['spans'], x),
    help: _atd_read_optional_field(_atd_read_string, x['help'], x),
  };
}

export function writeErrorSpan(x: ErrorSpan, context: any = x): any {
  return {
    'file': _atd_write_required_field('ErrorSpan', 'file', writeFpath, x.file, x),
    'start': _atd_write_required_field('ErrorSpan', 'start', writePositionBis, x.start, x),
    'end': _atd_write_required_field('ErrorSpan', 'end', writePositionBis, x.end, x),
    'source_hash': _atd_write_optional_field(_atd_write_string, x.source_hash, x),
    'config_start': _atd_write_optional_field(_atd_write_nullable(writePositionBis), x.config_start, x),
    'config_end': _atd_write_optional_field(_atd_write_nullable(writePositionBis), x.config_end, x),
    'config_path': _atd_write_optional_field(_atd_write_nullable(_atd_write_array(_atd_write_string)), x.config_path, x),
    'context_start': _atd_write_optional_field(_atd_write_nullable(writePositionBis), x.context_start, x),
    'context_end': _atd_write_optional_field(_atd_write_nullable(writePositionBis), x.context_end, x),
  };
}

export function readErrorSpan(x: any, context: any = x): ErrorSpan {
  return {
    file: _atd_read_required_field('ErrorSpan', 'file', readFpath, x['file'], x),
    start: _atd_read_required_field('ErrorSpan', 'start', readPositionBis, x['start'], x),
    end: _atd_read_required_field('ErrorSpan', 'end', readPositionBis, x['end'], x),
    source_hash: _atd_read_optional_field(_atd_read_string, x['source_hash'], x),
    config_start: _atd_read_optional_field(_atd_read_nullable(readPositionBis), x['config_start'], x),
    config_end: _atd_read_optional_field(_atd_read_nullable(readPositionBis), x['config_end'], x),
    config_path: _atd_read_optional_field(_atd_read_nullable(_atd_read_array(_atd_read_string)), x['config_path'], x),
    context_start: _atd_read_optional_field(_atd_read_nullable(readPositionBis), x['context_start'], x),
    context_end: _atd_read_optional_field(_atd_read_nullable(readPositionBis), x['context_end'], x),
  };
}

export function writePositionBis(x: PositionBis, context: any = x): any {
  return {
    'line': _atd_write_required_field('PositionBis', 'line', _atd_write_int, x.line, x),
    'col': _atd_write_required_field('PositionBis', 'col', _atd_write_int, x.col, x),
  };
}

export function readPositionBis(x: any, context: any = x): PositionBis {
  return {
    line: _atd_read_required_field('PositionBis', 'line', _atd_read_int, x['line'], x),
    col: _atd_read_required_field('PositionBis', 'col', _atd_read_int, x['col'], x),
  };
}

export function writeCliMatchCallTrace(x: CliMatchCallTrace, context: any = x): any {
  switch (x.kind) {
    case 'CliLoc':
      return ['CliLoc', ((x, context) => [writeLocation(x[0], x), _atd_write_string(x[1], x)])(x.value, x)]
    case 'CliCall':
      return ['CliCall', ((x, context) => [((x, context) => [writeLocation(x[0], x), _atd_write_string(x[1], x)])(x[0], x), _atd_write_array(writeCliMatchIntermediateVar)(x[1], x), writeCliMatchCallTrace(x[2], x)])(x.value, x)]
  }
}

export function readCliMatchCallTrace(x: any, context: any = x): CliMatchCallTrace {
  _atd_check_json_tuple(2, x, context)
  switch (x[0]) {
    case 'CliLoc':
      return { kind: 'CliLoc', value: ((x, context): [Location, string] => { _atd_check_json_tuple(2, x, context); return [readLocation(x[0], x), _atd_read_string(x[1], x)] })(x[1], x) }
    case 'CliCall':
      return { kind: 'CliCall', value: ((x, context): [[Location, string], CliMatchIntermediateVar[], CliMatchCallTrace] => { _atd_check_json_tuple(3, x, context); return [((x, context): [Location, string] => { _atd_check_json_tuple(2, x, context); return [readLocation(x[0], x), _atd_read_string(x[1], x)] })(x[0], x), _atd_read_array(readCliMatchIntermediateVar)(x[1], x), readCliMatchCallTrace(x[2], x)] })(x[1], x) }
    default:
      _atd_bad_json('CliMatchCallTrace', x, context)
      throw new Error('impossible')
  }
}

export function writeCliMatchDataflowTrace(x: CliMatchDataflowTrace, context: any = x): any {
  return {
    'taint_source': _atd_write_optional_field(writeCliMatchCallTrace, x.taint_source, x),
    'intermediate_vars': _atd_write_optional_field(_atd_write_array(writeCliMatchIntermediateVar), x.intermediate_vars, x),
    'taint_sink': _atd_write_optional_field(writeCliMatchCallTrace, x.taint_sink, x),
  };
}

export function readCliMatchDataflowTrace(x: any, context: any = x): CliMatchDataflowTrace {
  return {
    taint_source: _atd_read_optional_field(readCliMatchCallTrace, x['taint_source'], x),
    intermediate_vars: _atd_read_optional_field(_atd_read_array(readCliMatchIntermediateVar), x['intermediate_vars'], x),
    taint_sink: _atd_read_optional_field(readCliMatchCallTrace, x['taint_sink'], x),
  };
}

export function writeCliMatchTaintSource(x: CliMatchTaintSource, context: any = x): any {
  return {
    'location': _atd_write_required_field('CliMatchTaintSource', 'location', writeLocation, x.location, x),
    'content': _atd_write_required_field('CliMatchTaintSource', 'content', _atd_write_string, x.content, x),
  };
}

export function readCliMatchTaintSource(x: any, context: any = x): CliMatchTaintSource {
  return {
    location: _atd_read_required_field('CliMatchTaintSource', 'location', readLocation, x['location'], x),
    content: _atd_read_required_field('CliMatchTaintSource', 'content', _atd_read_string, x['content'], x),
  };
}

export function writeCliMatchIntermediateVar(x: CliMatchIntermediateVar, context: any = x): any {
  return {
    'location': _atd_write_required_field('CliMatchIntermediateVar', 'location', writeLocation, x.location, x),
    'content': _atd_write_required_field('CliMatchIntermediateVar', 'content', _atd_write_string, x.content, x),
  };
}

export function readCliMatchIntermediateVar(x: any, context: any = x): CliMatchIntermediateVar {
  return {
    location: _atd_read_required_field('CliMatchIntermediateVar', 'location', readLocation, x['location'], x),
    content: _atd_read_required_field('CliMatchIntermediateVar', 'content', _atd_read_string, x['content'], x),
  };
}

export function writeCliMatch(x: CliMatch, context: any = x): any {
  return {
    'check_id': _atd_write_required_field('CliMatch', 'check_id', writeRuleId, x.check_id, x),
    'path': _atd_write_required_field('CliMatch', 'path', writeFpath, x.path, x),
    'start': _atd_write_required_field('CliMatch', 'start', writePosition, x.start, x),
    'end': _atd_write_required_field('CliMatch', 'end', writePosition, x.end, x),
    'extra': _atd_write_required_field('CliMatch', 'extra', writeCliMatchExtra, x.extra, x),
  };
}

export function readCliMatch(x: any, context: any = x): CliMatch {
  return {
    check_id: _atd_read_required_field('CliMatch', 'check_id', readRuleId, x['check_id'], x),
    path: _atd_read_required_field('CliMatch', 'path', readFpath, x['path'], x),
    start: _atd_read_required_field('CliMatch', 'start', readPosition, x['start'], x),
    end: _atd_read_required_field('CliMatch', 'end', readPosition, x['end'], x),
    extra: _atd_read_required_field('CliMatch', 'extra', readCliMatchExtra, x['extra'], x),
  };
}

export function writeCliMatchExtra(x: CliMatchExtra, context: any = x): any {
  return {
    'metavars': _atd_write_optional_field(writeMetavars, x.metavars, x),
    'fingerprint': _atd_write_required_field('CliMatchExtra', 'fingerprint', _atd_write_string, x.fingerprint, x),
    'lines': _atd_write_required_field('CliMatchExtra', 'lines', _atd_write_string, x.lines, x),
    'message': _atd_write_required_field('CliMatchExtra', 'message', _atd_write_string, x.message, x),
    'metadata': _atd_write_required_field('CliMatchExtra', 'metadata', writeRawJson, x.metadata, x),
    'severity': _atd_write_required_field('CliMatchExtra', 'severity', _atd_write_string, x.severity, x),
    'fix': _atd_write_optional_field(_atd_write_string, x.fix, x),
    'fix_regex': _atd_write_optional_field(writeFixRegex, x.fix_regex, x),
    'is_ignored': _atd_write_optional_field(_atd_write_bool, x.is_ignored, x),
    'sca_info': _atd_write_optional_field(writeScaInfo, x.sca_info, x),
    'fixed_lines': _atd_write_optional_field(_atd_write_array(_atd_write_string), x.fixed_lines, x),
    'dataflow_trace': _atd_write_optional_field(writeCliMatchDataflowTrace, x.dataflow_trace, x),
    'engine_kind': _atd_write_optional_field(writeEngineKind, x.engine_kind, x),
    'validation_state': _atd_write_optional_field(writeValidationState, x.validation_state, x),
    'extra_extra': _atd_write_optional_field(writeRawJson, x.extra_extra, x),
  };
}

export function readCliMatchExtra(x: any, context: any = x): CliMatchExtra {
  return {
    metavars: _atd_read_optional_field(readMetavars, x['metavars'], x),
    fingerprint: _atd_read_required_field('CliMatchExtra', 'fingerprint', _atd_read_string, x['fingerprint'], x),
    lines: _atd_read_required_field('CliMatchExtra', 'lines', _atd_read_string, x['lines'], x),
    message: _atd_read_required_field('CliMatchExtra', 'message', _atd_read_string, x['message'], x),
    metadata: _atd_read_required_field('CliMatchExtra', 'metadata', readRawJson, x['metadata'], x),
    severity: _atd_read_required_field('CliMatchExtra', 'severity', _atd_read_string, x['severity'], x),
    fix: _atd_read_optional_field(_atd_read_string, x['fix'], x),
    fix_regex: _atd_read_optional_field(readFixRegex, x['fix_regex'], x),
    is_ignored: _atd_read_optional_field(_atd_read_bool, x['is_ignored'], x),
    sca_info: _atd_read_optional_field(readScaInfo, x['sca_info'], x),
    fixed_lines: _atd_read_optional_field(_atd_read_array(_atd_read_string), x['fixed_lines'], x),
    dataflow_trace: _atd_read_optional_field(readCliMatchDataflowTrace, x['dataflow_trace'], x),
    engine_kind: _atd_read_optional_field(readEngineKind, x['engine_kind'], x),
    validation_state: _atd_read_optional_field(readValidationState, x['validation_state'], x),
    extra_extra: _atd_read_optional_field(readRawJson, x['extra_extra'], x),
  };
}

export function writeFixRegex(x: FixRegex, context: any = x): any {
  return {
    'regex': _atd_write_required_field('FixRegex', 'regex', _atd_write_string, x.regex, x),
    'replacement': _atd_write_required_field('FixRegex', 'replacement', _atd_write_string, x.replacement, x),
    'count': _atd_write_optional_field(_atd_write_int, x.count, x),
  };
}

export function readFixRegex(x: any, context: any = x): FixRegex {
  return {
    regex: _atd_read_required_field('FixRegex', 'regex', _atd_read_string, x['regex'], x),
    replacement: _atd_read_required_field('FixRegex', 'replacement', _atd_read_string, x['replacement'], x),
    count: _atd_read_optional_field(_atd_read_int, x['count'], x),
  };
}

export function writeCliOutput(x: CliOutput, context: any = x): any {
  return {
    'version': _atd_write_optional_field(writeVersion, x.version, x),
    'errors': _atd_write_required_field('CliOutput', 'errors', _atd_write_array(writeCliError), x.errors, x),
    'results': _atd_write_required_field('CliOutput', 'results', _atd_write_array(writeCliMatch), x.results, x),
    'paths': _atd_write_required_field('CliOutput', 'paths', writeCliPaths, x.paths, x),
    'time': _atd_write_optional_field(writeCliTiming, x.time, x),
    'explanations': _atd_write_optional_field(_atd_write_array(writeMatchingExplanation), x.explanations, x),
    'rules_by_engine': _atd_write_optional_field(_atd_write_array(writeRuleIdAndEngineKind), x.rules_by_engine, x),
    'engine_requested': _atd_write_optional_field(writeEngineKind, x.engine_requested, x),
  };
}

export function readCliOutput(x: any, context: any = x): CliOutput {
  return {
    version: _atd_read_optional_field(readVersion, x['version'], x),
    errors: _atd_read_required_field('CliOutput', 'errors', _atd_read_array(readCliError), x['errors'], x),
    results: _atd_read_required_field('CliOutput', 'results', _atd_read_array(readCliMatch), x['results'], x),
    paths: _atd_read_required_field('CliOutput', 'paths', readCliPaths, x['paths'], x),
    time: _atd_read_optional_field(readCliTiming, x['time'], x),
    explanations: _atd_read_optional_field(_atd_read_array(readMatchingExplanation), x['explanations'], x),
    rules_by_engine: _atd_read_optional_field(_atd_read_array(readRuleIdAndEngineKind), x['rules_by_engine'], x),
    engine_requested: _atd_read_optional_field(readEngineKind, x['engine_requested'], x),
  };
}

export function writeCliOutputExtra(x: CliOutputExtra, context: any = x): any {
  return {
    'paths': _atd_write_required_field('CliOutputExtra', 'paths', writeCliPaths, x.paths, x),
    'time': _atd_write_optional_field(writeCliTiming, x.time, x),
    'explanations': _atd_write_optional_field(_atd_write_array(writeMatchingExplanation), x.explanations, x),
    'rules_by_engine': _atd_write_optional_field(_atd_write_array(writeRuleIdAndEngineKind), x.rules_by_engine, x),
    'engine_requested': _atd_write_optional_field(writeEngineKind, x.engine_requested, x),
  };
}

export function readCliOutputExtra(x: any, context: any = x): CliOutputExtra {
  return {
    paths: _atd_read_required_field('CliOutputExtra', 'paths', readCliPaths, x['paths'], x),
    time: _atd_read_optional_field(readCliTiming, x['time'], x),
    explanations: _atd_read_optional_field(_atd_read_array(readMatchingExplanation), x['explanations'], x),
    rules_by_engine: _atd_read_optional_field(_atd_read_array(readRuleIdAndEngineKind), x['rules_by_engine'], x),
    engine_requested: _atd_read_optional_field(readEngineKind, x['engine_requested'], x),
  };
}

export function writeCliPaths(x: CliPaths, context: any = x): any {
  return {
    'scanned': _atd_write_required_field('CliPaths', 'scanned', _atd_write_array(_atd_write_string), x.scanned, x),
    '_comment': _atd_write_optional_field(_atd_write_string, x._comment, x),
    'skipped': _atd_write_optional_field(_atd_write_array(writeCliSkippedTarget), x.skipped, x),
  };
}

export function readCliPaths(x: any, context: any = x): CliPaths {
  return {
    scanned: _atd_read_required_field('CliPaths', 'scanned', _atd_read_array(_atd_read_string), x['scanned'], x),
    _comment: _atd_read_optional_field(_atd_read_string, x['_comment'], x),
    skipped: _atd_read_optional_field(_atd_read_array(readCliSkippedTarget), x['skipped'], x),
  };
}

export function writeCliSkippedTarget(x: CliSkippedTarget, context: any = x): any {
  return {
    'path': _atd_write_required_field('CliSkippedTarget', 'path', writeFpath, x.path, x),
    'reason': _atd_write_required_field('CliSkippedTarget', 'reason', writeSkipReason, x.reason, x),
  };
}

export function readCliSkippedTarget(x: any, context: any = x): CliSkippedTarget {
  return {
    path: _atd_read_required_field('CliSkippedTarget', 'path', readFpath, x['path'], x),
    reason: _atd_read_required_field('CliSkippedTarget', 'reason', readSkipReason, x['reason'], x),
  };
}

export function writeCliTiming(x: CliTiming, context: any = x): any {
  return {
    'rules': _atd_write_required_field('CliTiming', 'rules', _atd_write_array(writeRuleIdDict), x.rules, x),
    'rules_parse_time': _atd_write_required_field('CliTiming', 'rules_parse_time', _atd_write_float, x.rules_parse_time, x),
    'profiling_times': _atd_write_required_field('CliTiming', 'profiling_times', _atd_write_assoc_map_to_object(_atd_write_float), x.profiling_times, x),
    'targets': _atd_write_required_field('CliTiming', 'targets', _atd_write_array(writeCliTargetTimes), x.targets, x),
    'total_bytes': _atd_write_required_field('CliTiming', 'total_bytes', _atd_write_int, x.total_bytes, x),
    'max_memory_bytes': _atd_write_optional_field(_atd_write_int, x.max_memory_bytes, x),
  };
}

export function readCliTiming(x: any, context: any = x): CliTiming {
  return {
    rules: _atd_read_required_field('CliTiming', 'rules', _atd_read_array(readRuleIdDict), x['rules'], x),
    rules_parse_time: _atd_read_required_field('CliTiming', 'rules_parse_time', _atd_read_float, x['rules_parse_time'], x),
    profiling_times: _atd_read_required_field('CliTiming', 'profiling_times', _atd_read_assoc_object_into_map(_atd_read_float), x['profiling_times'], x),
    targets: _atd_read_required_field('CliTiming', 'targets', _atd_read_array(readCliTargetTimes), x['targets'], x),
    total_bytes: _atd_read_required_field('CliTiming', 'total_bytes', _atd_read_int, x['total_bytes'], x),
    max_memory_bytes: _atd_read_optional_field(_atd_read_int, x['max_memory_bytes'], x),
  };
}

export function writeContributor(x: Contributor, context: any = x): any {
  return {
    'commit_author_name': _atd_write_required_field('Contributor', 'commit_author_name', _atd_write_string, x.commit_author_name, x),
    'commit_author_email': _atd_write_required_field('Contributor', 'commit_author_email', _atd_write_string, x.commit_author_email, x),
  };
}

export function readContributor(x: any, context: any = x): Contributor {
  return {
    commit_author_name: _atd_read_required_field('Contributor', 'commit_author_name', _atd_read_string, x['commit_author_name'], x),
    commit_author_email: _atd_read_required_field('Contributor', 'commit_author_email', _atd_read_string, x['commit_author_email'], x),
  };
}

export function writeContribution(x: Contribution, context: any = x): any {
  return {
    'commit_hash': _atd_write_required_field('Contribution', 'commit_hash', _atd_write_string, x.commit_hash, x),
    'commit_timestamp': _atd_write_required_field('Contribution', 'commit_timestamp', _atd_write_string, x.commit_timestamp, x),
    'contributor': _atd_write_required_field('Contribution', 'contributor', writeContributor, x.contributor, x),
  };
}

export function readContribution(x: any, context: any = x): Contribution {
  return {
    commit_hash: _atd_read_required_field('Contribution', 'commit_hash', _atd_read_string, x['commit_hash'], x),
    commit_timestamp: _atd_read_required_field('Contribution', 'commit_timestamp', _atd_read_string, x['commit_timestamp'], x),
    contributor: _atd_read_required_field('Contribution', 'contributor', readContributor, x['contributor'], x),
  };
}

export function writeContributions(x: Contributions, context: any = x): any {
  return _atd_write_array(writeContribution)(x, context);
}

export function readContributions(x: any, context: any = x): Contributions {
  return _atd_read_array(readContribution)(x, context);
}

export function writeRuleIdDict(x: RuleIdDict, context: any = x): any {
  return {
    'id': _atd_write_required_field('RuleIdDict', 'id', writeRuleId, x.id, x),
  };
}

export function readRuleIdDict(x: any, context: any = x): RuleIdDict {
  return {
    id: _atd_read_required_field('RuleIdDict', 'id', readRuleId, x['id'], x),
  };
}

export function writeCliTargetTimes(x: CliTargetTimes, context: any = x): any {
  return {
    'path': _atd_write_required_field('CliTargetTimes', 'path', writeFpath, x.path, x),
    'num_bytes': _atd_write_required_field('CliTargetTimes', 'num_bytes', _atd_write_int, x.num_bytes, x),
    'match_times': _atd_write_required_field('CliTargetTimes', 'match_times', _atd_write_array(_atd_write_float), x.match_times, x),
    'parse_times': _atd_write_required_field('CliTargetTimes', 'parse_times', _atd_write_array(_atd_write_float), x.parse_times, x),
    'run_time': _atd_write_required_field('CliTargetTimes', 'run_time', _atd_write_float, x.run_time, x),
  };
}

export function readCliTargetTimes(x: any, context: any = x): CliTargetTimes {
  return {
    path: _atd_read_required_field('CliTargetTimes', 'path', readFpath, x['path'], x),
    num_bytes: _atd_read_required_field('CliTargetTimes', 'num_bytes', _atd_read_int, x['num_bytes'], x),
    match_times: _atd_read_required_field('CliTargetTimes', 'match_times', _atd_read_array(_atd_read_float), x['match_times'], x),
    parse_times: _atd_read_required_field('CliTargetTimes', 'parse_times', _atd_read_array(_atd_read_float), x['parse_times'], x),
    run_time: _atd_read_required_field('CliTargetTimes', 'run_time', _atd_read_float, x['run_time'], x),
  };
}

export function writeScaInfo(x: ScaInfo, context: any = x): any {
  return {
    'reachable': _atd_write_required_field('ScaInfo', 'reachable', _atd_write_bool, x.reachable, x),
    'reachability_rule': _atd_write_required_field('ScaInfo', 'reachability_rule', _atd_write_bool, x.reachability_rule, x),
    'sca_finding_schema': _atd_write_required_field('ScaInfo', 'sca_finding_schema', _atd_write_int, x.sca_finding_schema, x),
    'dependency_match': _atd_write_required_field('ScaInfo', 'dependency_match', writeDependencyMatch, x.dependency_match, x),
  };
}

export function readScaInfo(x: any, context: any = x): ScaInfo {
  return {
    reachable: _atd_read_required_field('ScaInfo', 'reachable', _atd_read_bool, x['reachable'], x),
    reachability_rule: _atd_read_required_field('ScaInfo', 'reachability_rule', _atd_read_bool, x['reachability_rule'], x),
    sca_finding_schema: _atd_read_required_field('ScaInfo', 'sca_finding_schema', _atd_read_int, x['sca_finding_schema'], x),
    dependency_match: _atd_read_required_field('ScaInfo', 'dependency_match', readDependencyMatch, x['dependency_match'], x),
  };
}

export function writeDependencyMatch(x: DependencyMatch, context: any = x): any {
  return {
    'dependency_pattern': _atd_write_required_field('DependencyMatch', 'dependency_pattern', writeDependencyPattern, x.dependency_pattern, x),
    'found_dependency': _atd_write_required_field('DependencyMatch', 'found_dependency', writeFoundDependency, x.found_dependency, x),
    'lockfile': _atd_write_required_field('DependencyMatch', 'lockfile', _atd_write_string, x.lockfile, x),
  };
}

export function readDependencyMatch(x: any, context: any = x): DependencyMatch {
  return {
    dependency_pattern: _atd_read_required_field('DependencyMatch', 'dependency_pattern', readDependencyPattern, x['dependency_pattern'], x),
    found_dependency: _atd_read_required_field('DependencyMatch', 'found_dependency', readFoundDependency, x['found_dependency'], x),
    lockfile: _atd_read_required_field('DependencyMatch', 'lockfile', _atd_read_string, x['lockfile'], x),
  };
}

export function writeEcosystem(x: Ecosystem, context: any = x): any {
  switch (x.kind) {
    case 'Npm':
      return 'npm'
    case 'Pypi':
      return 'pypi'
    case 'Gem':
      return 'gem'
    case 'Gomod':
      return 'gomod'
    case 'Cargo':
      return 'cargo'
    case 'Maven':
      return 'maven'
    case 'Composer':
      return 'composer'
    case 'Nuget':
      return 'nuget'
  }
}

export function readEcosystem(x: any, context: any = x): Ecosystem {
  switch (x) {
    case 'npm':
      return { kind: 'Npm' }
    case 'pypi':
      return { kind: 'Pypi' }
    case 'gem':
      return { kind: 'Gem' }
    case 'gomod':
      return { kind: 'Gomod' }
    case 'cargo':
      return { kind: 'Cargo' }
    case 'maven':
      return { kind: 'Maven' }
    case 'composer':
      return { kind: 'Composer' }
    case 'nuget':
      return { kind: 'Nuget' }
    default:
      _atd_bad_json('Ecosystem', x, context)
      throw new Error('impossible')
  }
}

export function writeTransitivity(x: Transitivity, context: any = x): any {
  switch (x.kind) {
    case 'Direct':
      return 'direct'
    case 'Transitive':
      return 'transitive'
    case 'Unknown':
      return 'unknown'
  }
}

export function readTransitivity(x: any, context: any = x): Transitivity {
  switch (x) {
    case 'direct':
      return { kind: 'Direct' }
    case 'transitive':
      return { kind: 'Transitive' }
    case 'unknown':
      return { kind: 'Unknown' }
    default:
      _atd_bad_json('Transitivity', x, context)
      throw new Error('impossible')
  }
}

export function writeDependencyPattern(x: DependencyPattern, context: any = x): any {
  return {
    'ecosystem': _atd_write_required_field('DependencyPattern', 'ecosystem', writeEcosystem, x.ecosystem, x),
    'package': _atd_write_required_field('DependencyPattern', 'package', _atd_write_string, x.package_, x),
    'semver_range': _atd_write_required_field('DependencyPattern', 'semver_range', _atd_write_string, x.semver_range, x),
  };
}

export function readDependencyPattern(x: any, context: any = x): DependencyPattern {
  return {
    ecosystem: _atd_read_required_field('DependencyPattern', 'ecosystem', readEcosystem, x['ecosystem'], x),
    package_: _atd_read_required_field('DependencyPattern', 'package', _atd_read_string, x['package'], x),
    semver_range: _atd_read_required_field('DependencyPattern', 'semver_range', _atd_read_string, x['semver_range'], x),
  };
}

export function writeDependencyChild(x: DependencyChild, context: any = x): any {
  return {
    'package': _atd_write_required_field('DependencyChild', 'package', _atd_write_string, x.package_, x),
    'version': _atd_write_required_field('DependencyChild', 'version', _atd_write_string, x.version, x),
  };
}

export function readDependencyChild(x: any, context: any = x): DependencyChild {
  return {
    package_: _atd_read_required_field('DependencyChild', 'package', _atd_read_string, x['package'], x),
    version: _atd_read_required_field('DependencyChild', 'version', _atd_read_string, x['version'], x),
  };
}

export function writeFoundDependency(x: FoundDependency, context: any = x): any {
  return {
    'package': _atd_write_required_field('FoundDependency', 'package', _atd_write_string, x.package_, x),
    'version': _atd_write_required_field('FoundDependency', 'version', _atd_write_string, x.version, x),
    'ecosystem': _atd_write_required_field('FoundDependency', 'ecosystem', writeEcosystem, x.ecosystem, x),
    'allowed_hashes': _atd_write_required_field('FoundDependency', 'allowed_hashes', _atd_write_assoc_map_to_object(_atd_write_array(_atd_write_string)), x.allowed_hashes, x),
    'resolved_url': _atd_write_optional_field(_atd_write_string, x.resolved_url, x),
    'transitivity': _atd_write_required_field('FoundDependency', 'transitivity', writeTransitivity, x.transitivity, x),
    'line_number': _atd_write_optional_field(_atd_write_int, x.line_number, x),
    'children': _atd_write_optional_field(_atd_write_array(writeDependencyChild), x.children, x),
  };
}

export function readFoundDependency(x: any, context: any = x): FoundDependency {
  return {
    package_: _atd_read_required_field('FoundDependency', 'package', _atd_read_string, x['package'], x),
    version: _atd_read_required_field('FoundDependency', 'version', _atd_read_string, x['version'], x),
    ecosystem: _atd_read_required_field('FoundDependency', 'ecosystem', readEcosystem, x['ecosystem'], x),
    allowed_hashes: _atd_read_required_field('FoundDependency', 'allowed_hashes', _atd_read_assoc_object_into_map(_atd_read_array(_atd_read_string)), x['allowed_hashes'], x),
    resolved_url: _atd_read_optional_field(_atd_read_string, x['resolved_url'], x),
    transitivity: _atd_read_required_field('FoundDependency', 'transitivity', readTransitivity, x['transitivity'], x),
    line_number: _atd_read_optional_field(_atd_read_int, x['line_number'], x),
    children: _atd_read_optional_field(_atd_read_array(readDependencyChild), x['children'], x),
  };
}

export function writeScaParserName(x: ScaParserName, context: any = x): any {
  switch (x.kind) {
    case 'Gemfile_lock':
      return 'gemfile_lock'
    case 'Go_mod':
      return 'go_mod'
    case 'Go_sum':
      return 'go_sum'
    case 'Gradle_lockfile':
      return 'gradle_lockfile'
    case 'Gradle_build':
      return 'gradle_build'
    case 'Jsondoc':
      return 'jsondoc'
    case 'Pipfile':
      return 'pipfile'
    case 'Pnpm_lock':
      return 'pnpm_lock'
    case 'Poetry_lock':
      return 'poetry_lock'
    case 'Pyproject_toml':
      return 'pyproject_toml'
    case 'Requirements':
      return 'requirements'
    case 'Yarn_1':
      return 'yarn_1'
    case 'Yarn_2':
      return 'yarn_2'
    case 'Pomtree':
      return 'pomtree'
    case 'Cargo_parser':
      return 'cargo'
    case 'Composer_lock':
      return 'composer_lock'
  }
}

export function readScaParserName(x: any, context: any = x): ScaParserName {
  switch (x) {
    case 'gemfile_lock':
      return { kind: 'Gemfile_lock' }
    case 'go_mod':
      return { kind: 'Go_mod' }
    case 'go_sum':
      return { kind: 'Go_sum' }
    case 'gradle_lockfile':
      return { kind: 'Gradle_lockfile' }
    case 'gradle_build':
      return { kind: 'Gradle_build' }
    case 'jsondoc':
      return { kind: 'Jsondoc' }
    case 'pipfile':
      return { kind: 'Pipfile' }
    case 'pnpm_lock':
      return { kind: 'Pnpm_lock' }
    case 'poetry_lock':
      return { kind: 'Poetry_lock' }
    case 'pyproject_toml':
      return { kind: 'Pyproject_toml' }
    case 'requirements':
      return { kind: 'Requirements' }
    case 'yarn_1':
      return { kind: 'Yarn_1' }
    case 'yarn_2':
      return { kind: 'Yarn_2' }
    case 'pomtree':
      return { kind: 'Pomtree' }
    case 'cargo':
      return { kind: 'Cargo_parser' }
    case 'composer_lock':
      return { kind: 'Composer_lock' }
    default:
      _atd_bad_json('ScaParserName', x, context)
      throw new Error('impossible')
  }
}

export function writeDependencyParserError(x: DependencyParserError, context: any = x): any {
  return {
    'path': _atd_write_required_field('DependencyParserError', 'path', _atd_write_string, x.path, x),
    'parser': _atd_write_required_field('DependencyParserError', 'parser', writeScaParserName, x.parser, x),
    'reason': _atd_write_required_field('DependencyParserError', 'reason', _atd_write_string, x.reason, x),
    'line': _atd_write_optional_field(_atd_write_int, x.line, x),
    'col': _atd_write_optional_field(_atd_write_int, x.col, x),
    'text': _atd_write_optional_field(_atd_write_string, x.text, x),
  };
}

export function readDependencyParserError(x: any, context: any = x): DependencyParserError {
  return {
    path: _atd_read_required_field('DependencyParserError', 'path', _atd_read_string, x['path'], x),
    parser: _atd_read_required_field('DependencyParserError', 'parser', readScaParserName, x['parser'], x),
    reason: _atd_read_required_field('DependencyParserError', 'reason', _atd_read_string, x['reason'], x),
    line: _atd_read_optional_field(_atd_read_int, x['line'], x),
    col: _atd_read_optional_field(_atd_read_int, x['col'], x),
    text: _atd_read_optional_field(_atd_read_string, x['text'], x),
  };
}

export function writeCiScanResults(x: CiScanResults, context: any = x): any {
  return {
    'findings': _atd_write_required_field('CiScanResults', 'findings', _atd_write_array(writeFinding), x.findings, x),
    'ignores': _atd_write_required_field('CiScanResults', 'ignores', _atd_write_array(writeFinding), x.ignores, x),
    'token': _atd_write_required_field('CiScanResults', 'token', _atd_write_nullable(_atd_write_string), x.token, x),
    'searched_paths': _atd_write_required_field('CiScanResults', 'searched_paths', _atd_write_array(_atd_write_string), x.searched_paths, x),
    'renamed_paths': _atd_write_required_field('CiScanResults', 'renamed_paths', _atd_write_array(_atd_write_string), x.renamed_paths, x),
    'rule_ids': _atd_write_required_field('CiScanResults', 'rule_ids', _atd_write_array(_atd_write_string), x.rule_ids, x),
    'contributions': _atd_write_optional_field(writeContributions, x.contributions, x),
    'dependencies': _atd_write_optional_field(writeCiScanDependencies, x.dependencies, x),
  };
}

export function readCiScanResults(x: any, context: any = x): CiScanResults {
  return {
    findings: _atd_read_required_field('CiScanResults', 'findings', _atd_read_array(readFinding), x['findings'], x),
    ignores: _atd_read_required_field('CiScanResults', 'ignores', _atd_read_array(readFinding), x['ignores'], x),
    token: _atd_read_required_field('CiScanResults', 'token', _atd_read_nullable(_atd_read_string), x['token'], x),
    searched_paths: _atd_read_required_field('CiScanResults', 'searched_paths', _atd_read_array(_atd_read_string), x['searched_paths'], x),
    renamed_paths: _atd_read_required_field('CiScanResults', 'renamed_paths', _atd_read_array(_atd_read_string), x['renamed_paths'], x),
    rule_ids: _atd_read_required_field('CiScanResults', 'rule_ids', _atd_read_array(_atd_read_string), x['rule_ids'], x),
    contributions: _atd_read_optional_field(readContributions, x['contributions'], x),
    dependencies: _atd_read_optional_field(readCiScanDependencies, x['dependencies'], x),
  };
}

export function writeParsingStats(x: ParsingStats, context: any = x): any {
  return {
    'targets_parsed': _atd_write_required_field('ParsingStats', 'targets_parsed', _atd_write_int, x.targets_parsed, x),
    'num_targets': _atd_write_required_field('ParsingStats', 'num_targets', _atd_write_int, x.num_targets, x),
    'bytes_parsed': _atd_write_required_field('ParsingStats', 'bytes_parsed', _atd_write_int, x.bytes_parsed, x),
    'num_bytes': _atd_write_required_field('ParsingStats', 'num_bytes', _atd_write_int, x.num_bytes, x),
  };
}

export function readParsingStats(x: any, context: any = x): ParsingStats {
  return {
    targets_parsed: _atd_read_required_field('ParsingStats', 'targets_parsed', _atd_read_int, x['targets_parsed'], x),
    num_targets: _atd_read_required_field('ParsingStats', 'num_targets', _atd_read_int, x['num_targets'], x),
    bytes_parsed: _atd_read_required_field('ParsingStats', 'bytes_parsed', _atd_read_int, x['bytes_parsed'], x),
    num_bytes: _atd_read_required_field('ParsingStats', 'num_bytes', _atd_read_int, x['num_bytes'], x),
  };
}

export function writeCiScanCompleteStats(x: CiScanCompleteStats, context: any = x): any {
  return {
    'findings': _atd_write_required_field('CiScanCompleteStats', 'findings', _atd_write_int, x.findings, x),
    'errors': _atd_write_required_field('CiScanCompleteStats', 'errors', _atd_write_array(writeCliError), x.errors, x),
    'total_time': _atd_write_required_field('CiScanCompleteStats', 'total_time', _atd_write_float, x.total_time, x),
    'unsupported_exts': _atd_write_required_field('CiScanCompleteStats', 'unsupported_exts', _atd_write_assoc_map_to_object(_atd_write_int), x.unsupported_exts, x),
    'lockfile_scan_info': _atd_write_required_field('CiScanCompleteStats', 'lockfile_scan_info', _atd_write_assoc_map_to_object(_atd_write_int), x.lockfile_scan_info, x),
    'parse_rate': _atd_write_required_field('CiScanCompleteStats', 'parse_rate', _atd_write_assoc_map_to_object(writeParsingStats), x.parse_rate, x),
    'engine_requested': _atd_write_optional_field(_atd_write_string, x.engine_requested, x),
  };
}

export function readCiScanCompleteStats(x: any, context: any = x): CiScanCompleteStats {
  return {
    findings: _atd_read_required_field('CiScanCompleteStats', 'findings', _atd_read_int, x['findings'], x),
    errors: _atd_read_required_field('CiScanCompleteStats', 'errors', _atd_read_array(readCliError), x['errors'], x),
    total_time: _atd_read_required_field('CiScanCompleteStats', 'total_time', _atd_read_float, x['total_time'], x),
    unsupported_exts: _atd_read_required_field('CiScanCompleteStats', 'unsupported_exts', _atd_read_assoc_object_into_map(_atd_read_int), x['unsupported_exts'], x),
    lockfile_scan_info: _atd_read_required_field('CiScanCompleteStats', 'lockfile_scan_info', _atd_read_assoc_object_into_map(_atd_read_int), x['lockfile_scan_info'], x),
    parse_rate: _atd_read_required_field('CiScanCompleteStats', 'parse_rate', _atd_read_assoc_object_into_map(readParsingStats), x['parse_rate'], x),
    engine_requested: _atd_read_optional_field(_atd_read_string, x['engine_requested'], x),
  };
}

export function writeCiScanDependencies(x: CiScanDependencies, context: any = x): any {
  return _atd_write_assoc_map_to_object(_atd_write_array(writeFoundDependency))(x, context);
}

export function readCiScanDependencies(x: any, context: any = x): CiScanDependencies {
  return _atd_read_assoc_object_into_map(_atd_read_array(readFoundDependency))(x, context);
}

export function writeCiScanCompleteResponse(x: CiScanCompleteResponse, context: any = x): any {
  return {
    'exit_code': _atd_write_required_field('CiScanCompleteResponse', 'exit_code', _atd_write_int, x.exit_code, x),
    'stats': _atd_write_required_field('CiScanCompleteResponse', 'stats', writeCiScanCompleteStats, x.stats, x),
    'dependencies': _atd_write_optional_field(writeCiScanDependencies, x.dependencies, x),
    'dependency_parser_errors': _atd_write_optional_field(_atd_write_array(writeDependencyParserError), x.dependency_parser_errors, x),
    'task_id': _atd_write_optional_field(_atd_write_string, x.task_id, x),
  };
}

export function readCiScanCompleteResponse(x: any, context: any = x): CiScanCompleteResponse {
  return {
    exit_code: _atd_read_required_field('CiScanCompleteResponse', 'exit_code', _atd_read_int, x['exit_code'], x),
    stats: _atd_read_required_field('CiScanCompleteResponse', 'stats', readCiScanCompleteStats, x['stats'], x),
    dependencies: _atd_read_optional_field(readCiScanDependencies, x['dependencies'], x),
    dependency_parser_errors: _atd_read_optional_field(_atd_read_array(readDependencyParserError), x['dependency_parser_errors'], x),
    task_id: _atd_read_optional_field(_atd_read_string, x['task_id'], x),
  };
}

export function writeFindingHashes(x: FindingHashes, context: any = x): any {
  return {
    'start_line_hash': _atd_write_required_field('FindingHashes', 'start_line_hash', _atd_write_string, x.start_line_hash, x),
    'end_line_hash': _atd_write_required_field('FindingHashes', 'end_line_hash', _atd_write_string, x.end_line_hash, x),
    'code_hash': _atd_write_required_field('FindingHashes', 'code_hash', _atd_write_string, x.code_hash, x),
    'pattern_hash': _atd_write_required_field('FindingHashes', 'pattern_hash', _atd_write_string, x.pattern_hash, x),
  };
}

export function readFindingHashes(x: any, context: any = x): FindingHashes {
  return {
    start_line_hash: _atd_read_required_field('FindingHashes', 'start_line_hash', _atd_read_string, x['start_line_hash'], x),
    end_line_hash: _atd_read_required_field('FindingHashes', 'end_line_hash', _atd_read_string, x['end_line_hash'], x),
    code_hash: _atd_read_required_field('FindingHashes', 'code_hash', _atd_read_string, x['code_hash'], x),
    pattern_hash: _atd_read_required_field('FindingHashes', 'pattern_hash', _atd_read_string, x['pattern_hash'], x),
  };
}

export function writeFinding(x: Finding, context: any = x): any {
  return {
    'check_id': _atd_write_required_field('Finding', 'check_id', writeRuleId, x.check_id, x),
    'path': _atd_write_required_field('Finding', 'path', writeFpath, x.path, x),
    'line': _atd_write_required_field('Finding', 'line', _atd_write_int, x.line, x),
    'column': _atd_write_required_field('Finding', 'column', _atd_write_int, x.column, x),
    'end_line': _atd_write_required_field('Finding', 'end_line', _atd_write_int, x.end_line, x),
    'end_column': _atd_write_required_field('Finding', 'end_column', _atd_write_int, x.end_column, x),
    'message': _atd_write_required_field('Finding', 'message', _atd_write_string, x.message, x),
    'severity': _atd_write_required_field('Finding', 'severity', ((x: any, context): any => x), x.severity, x),
    'index': _atd_write_required_field('Finding', 'index', _atd_write_int, x.index, x),
    'commit_date': _atd_write_required_field('Finding', 'commit_date', _atd_write_string, x.commit_date, x),
    'syntactic_id': _atd_write_required_field('Finding', 'syntactic_id', _atd_write_string, x.syntactic_id, x),
    'match_based_id': _atd_write_optional_field(_atd_write_string, x.match_based_id, x),
    'hashes': _atd_write_optional_field(writeFindingHashes, x.hashes, x),
    'metadata': _atd_write_required_field('Finding', 'metadata', writeRawJson, x.metadata, x),
    'is_blocking': _atd_write_required_field('Finding', 'is_blocking', _atd_write_bool, x.is_blocking, x),
    'fixed_lines': _atd_write_optional_field(_atd_write_array(_atd_write_string), x.fixed_lines, x),
    'sca_info': _atd_write_optional_field(writeScaInfo, x.sca_info, x),
    'dataflow_trace': _atd_write_optional_field(writeCliMatchDataflowTrace, x.dataflow_trace, x),
  };
}

export function readFinding(x: any, context: any = x): Finding {
  return {
    check_id: _atd_read_required_field('Finding', 'check_id', readRuleId, x['check_id'], x),
    path: _atd_read_required_field('Finding', 'path', readFpath, x['path'], x),
    line: _atd_read_required_field('Finding', 'line', _atd_read_int, x['line'], x),
    column: _atd_read_required_field('Finding', 'column', _atd_read_int, x['column'], x),
    end_line: _atd_read_required_field('Finding', 'end_line', _atd_read_int, x['end_line'], x),
    end_column: _atd_read_required_field('Finding', 'end_column', _atd_read_int, x['end_column'], x),
    message: _atd_read_required_field('Finding', 'message', _atd_read_string, x['message'], x),
    severity: _atd_read_required_field('Finding', 'severity', ((x: any, context): any => x), x['severity'], x),
    index: _atd_read_required_field('Finding', 'index', _atd_read_int, x['index'], x),
    commit_date: _atd_read_required_field('Finding', 'commit_date', _atd_read_string, x['commit_date'], x),
    syntactic_id: _atd_read_required_field('Finding', 'syntactic_id', _atd_read_string, x['syntactic_id'], x),
    match_based_id: _atd_read_optional_field(_atd_read_string, x['match_based_id'], x),
    hashes: _atd_read_optional_field(readFindingHashes, x['hashes'], x),
    metadata: _atd_read_required_field('Finding', 'metadata', readRawJson, x['metadata'], x),
    is_blocking: _atd_read_required_field('Finding', 'is_blocking', _atd_read_bool, x['is_blocking'], x),
    fixed_lines: _atd_read_optional_field(_atd_read_array(_atd_read_string), x['fixed_lines'], x),
    sca_info: _atd_read_optional_field(readScaInfo, x['sca_info'], x),
    dataflow_trace: _atd_read_optional_field(readCliMatchDataflowTrace, x['dataflow_trace'], x),
  };
}


/////////////////////////////////////////////////////////////////////
// Runtime library
/////////////////////////////////////////////////////////////////////

export type Option<T> = null | { value: T }

function _atd_missing_json_field(type_name: string, json_field_name: string) {
    throw new Error(`missing field '${json_field_name}'` +
                    ` in JSON object of type '${type_name}'`)
}

function _atd_missing_ts_field(type_name: string, ts_field_name: string) {
    throw new Error(`missing field '${ts_field_name}'` +
                    ` in TypeScript object of type '${type_name}'`)
}

function _atd_bad_json(expected_type: string, json_value: any, context: any) {
  let value_str = JSON.stringify(json_value)
  if (value_str.length > 200)
    value_str = value_str.substring(0, 200) + '';

  throw new Error(`incompatible JSON value where` +
                  ` type '${expected_type}' was expected: '${value_str}'.` +
                  ` Occurs in '${JSON.stringify(context)}'.`)
}

function _atd_bad_ts(expected_type: string, ts_value: any, context: any) {
  let value_str = JSON.stringify(ts_value)
  if (value_str.length > 200)
    value_str = value_str.substring(0, 200) + '';

  throw new Error(`incompatible TypeScript value where` +
                  ` type '${expected_type}' was expected: '${value_str}'.` +
                  ` Occurs in '${JSON.stringify(context)}'.`)
}

function _atd_check_json_tuple(len: number /*int*/, x: any, context: any) {
  if (! Array.isArray(x) || x.length !== len)
    _atd_bad_json('tuple of length ' + len, x, context);
}

function _atd_read_unit(x: any, context: any): null {
  if (x === null)
    return null
  else {
    _atd_bad_json('null', x, context)
    throw new Error('impossible')
  }
}

function _atd_read_bool(x: any, context: any): boolean {
  if (typeof x === 'boolean')
    return x
  else {
    _atd_bad_json('boolean', x, context)
    throw new Error('impossible')
  }
}

function _atd_read_int(x: any, context: any): number /*int*/ {
  if (Number.isInteger(x))
    return x
  else {
    _atd_bad_json('integer', x, context)
    throw new Error('impossible')
  }
}

function _atd_read_float(x: any, context: any): number {
  if (isFinite(x))
    return x
  else {
    _atd_bad_json('number', x, context)
    throw new Error('impossible')
  }
}

function _atd_read_string(x: any, context: any): string {
  if (typeof x === 'string')
    return x
  else {
    _atd_bad_json('string', x, context)
    throw new Error('impossible')
  }
}

function _atd_read_required_field<T>(type_name: string,
                                     field_name: string,
                                     read_elt: (x: any, context: any) => T,
                                     x: any,
                                     context: any): T {
  if (x === undefined) {
    _atd_missing_json_field(type_name, field_name)
    throw new Error('impossible')
  }
  else
    return read_elt(x, context)
}

function _atd_read_optional_field<T>(read_elt: (x: any, context: any) => T,
                                     x: any,
                                     context: any): T {
  if (x === undefined || x === null)
    return x
  else
    return read_elt(x, context)
}

function _atd_read_field_with_default<T>(read_elt: (x: any, context: any) => T,
                                         default_: T,
                                         x: any,
                                         context: any): T {
  if (x === undefined || x === null)
    return default_
  else
    return read_elt(x, context)
}

function _atd_read_option<T>(read_elt: (x: any, context: any) => T):
  (x: any, context: any) => Option<T> {
  function read_option(x: any, context: any): Option<T> {
    if (x === 'None')
      return null
    else {
      _atd_check_json_tuple(2, x, context);
      switch (x[0]) {
        case 'Some':
          return { value: read_elt(x[1], context) }
        default:
          _atd_bad_json('option', x, context)
          throw new Error('impossible')
      }
    }
  }
  return read_option
}

function _atd_read_nullable<T>(read_elt: (x: any, context: any) => T):
  (x: any, context: any) => T | null {
  function read_nullable(x: any, context: any): T | null {
    if (x === null)
      return null
    else
      return read_elt(x, context)
  }
  return read_nullable
}

function _atd_read_array<T>(read_elt: (x: any, context: any) => T):
  (elts: any, context: any) => T[] {
  function read_array(elts: any, context: any): T[] {
    if (Array.isArray(elts))
      return elts.map((x) => read_elt(x, elts))
    else {
      _atd_bad_json('array', elts, context)
      throw new Error('impossible')
    }
  }
  return read_array
}

function _atd_read_assoc_array_into_map<K, V>(
    read_key: (key: any, context: any) => K,
    read_value: (value: any, context: any) => V
  ): (x: any, context: any) => Map<K, V> {
  function read_assoc(elts: any, context: any): Map<K, V> {
    if (Array.isArray(elts)) {
      const res = new Map<K, V>([])
      for (const x of elts) {
        if (Array.isArray(x) && x.length === 2)
          res.set(read_key(x[0], x), read_value(x[1], x))
        else {
          _atd_bad_json('pair', x, elts)
          throw new Error('impossible')
        }
      }
      return res
    }
    else {
      _atd_bad_json('array', elts, context)
      throw new Error('impossible')
    }
  }
  return read_assoc
}

function _atd_read_assoc_object_into_map<T>(
    read_value: (value: any, context: any) => T
  ): (x: any, context: any) => Map<string, T> {
  function read_assoc(elts: any, context: any): Map<string, T> {
    if (typeof elts === 'object') {
      const res = new Map<string, T>([])
      for (const [key, value] of Object.entries(elts))
        res.set(key, read_value(value, elts))
      return res
    }
    else {
      _atd_bad_json('object', elts, context)
      throw new Error('impossible')
    }
  }
  return read_assoc
}

function _atd_read_assoc_object_into_array<T>(
    read_value: (value: any, context: any) => T
  ): (x: any, context: any) => [string, T][] {
  function read_assoc(elts: any, context: any): [string, T][] {
    if (typeof elts === 'object') {
      const res: [string, T][] = []
      for (const [key, value] of Object.entries(elts))
        res.push([key, read_value(value, elts)])
      return res
    }
    else {
      _atd_bad_json('object', elts, context)
      throw new Error('impossible')
    }
  }
  return read_assoc
}

function _atd_write_unit(x: any, context: any) {
  if (x === null)
    return x
  else {
    _atd_bad_ts('null', x, context)
    throw new Error('impossible')
  }
}

function _atd_write_bool(x: any, context: any): boolean {
  if (typeof x === 'boolean')
    return x
  else {
    _atd_bad_ts('boolean', x, context)
    throw new Error('impossible')
  }
}

function _atd_write_int(x: any, context: any): number /*int*/ {
  if (Number.isInteger(x))
    return x
  else {
    _atd_bad_ts('integer', x, context)
    throw new Error('impossible')
  }
}

function _atd_write_float(x: any, context: any): number {
  if (isFinite(x))
    return x
  else {
    _atd_bad_ts('number', x, context)
    throw new Error('impossible')
  }
}

function _atd_write_string(x: any, context: any): string {
  if (typeof x === 'string')
    return x
  else {
    _atd_bad_ts('string', x, context)
    throw new Error('impossible')
  }
}

function _atd_write_option<T>(write_elt: (x: T, context: any) => any):
   (elts: Option<T>, context: any) => any {
  function write_option(x: Option<T>, context: any): any {
    if (x === null)
      return 'None'
    else
      return ['Some', write_elt(x.value, context)]
  }
  return write_option
}

function _atd_write_nullable<T>(write_elt: (x: T, context: any) => any):
  (x: T | null, context: any) => any {
  function write_option(x: T | null, context: any): any {
    if (x === null)
      return null
    else
      return write_elt(x, context)
  }
  return write_option
}

function _atd_write_array<T>(write_elt: (elt: T, context: any) => any):
  (elts: T[], context: any) => any {
  return ((elts: T[], context: any): any =>
    elts.map((x) => write_elt(x, elts))
  )
}

function _atd_write_assoc_map_to_array<K, V>(
    write_key: (key: K, context: any) => any,
    write_value: (value: V, context: any) => any
  ): (elts: Map<K, V>, context: any) => any {
  function write_assoc(elts: Map<K, V>, context: any): any {
    const res: any = []
    elts.forEach((value: V, key: K) =>
      res.push([write_key(key, elts), write_value(value, elts)])
    )
    return res
  }
  return write_assoc
}

function _atd_write_assoc_map_to_object<T>(
    write_value: (value: T, context: any) => any
  ): (elts: Map<string, T>, context: any) => any {
  function write_assoc(elts: Map<string, T>, context: any): any {
    const res: any = {}
    elts.forEach((value: T, key: string) =>
      res[key] = write_value(value, elts)
    )
    return res
  }
  return write_assoc
}

function _atd_write_assoc_array_to_object<T>(
    write_value: (value: T, context: any) => any
  ): (elts: [string, T][], context: any) => any {
  function write_assoc(elts: [string, T][], context: any): any {
    const res: any = {}
    for (const [key, value] of elts)
      res[key] = write_value(value, elts)
    return res
  }
  return write_assoc
}

function _atd_write_required_field<T>(type_name: string,
                                      field_name: string,
                                      write_elt: (x: T, context: any) => any,
                                      x: T,
                                      context: any): any {
  if (x === undefined) {
    _atd_missing_ts_field(type_name, field_name)
    throw new Error('impossible')
  }
  else
    return write_elt(x, context)
}

function _atd_write_optional_field<T>(write_elt: (x: T, context: any) => any,
                                      x: T | undefined,
                                      context: any): any {
  if (x === undefined || x === null)
    return x
  else
    return write_elt(x, context)
}

function _atd_write_field_with_default<T>(
  write_elt: (x: T, context: any) => any,
  default_: T,
  x: T,
  context: any
): T {
  const value = (x === undefined || x === null) ? default_ : x
  return write_elt(value, context)
}

