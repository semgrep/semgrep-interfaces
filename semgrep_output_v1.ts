// Generated by atdts from type definitions in 'Semgrep_output_v1.atd'.
//
// Type-safe translations from/to JSON
//
// For each type 'Foo', there is a pair of functions:
// - 'writeFoo': convert a 'Foo' value into a JSON-compatible value.
// - 'readFoo': convert a JSON-compatible value into a TypeScript value
//   of type 'Foo'.


export type RawJson = any

export type Position = {
  line: Int;
  col: Int;
  offset: Int;
}

export type Location = {
  path: string;
  start: Position;
  end: Position;
}

export type RuleId = string

export type CoreMatch = {
  rule_id: RuleId;
  location: Location;
  extra: CoreMatchExtra;
}

export type Metavars = [string, MetavarValue][]

export type CoreMatchExtra = {
  message?: string;
  metavars: Metavars;
}

export type MetavarValue = {
  start: Position;
  end: Position;
  abstract_content: string;
  propagated_value?: SvalueValue;
  unique_id: UniqueId;
}

export type SvalueValue = {
  svalue_start?: Position;
  svalue_end?: Position;
  svalue_abstract_content: string;
}

export type UniqueId = {
  type_: UniqueIdType;
  md5sum?: string;
  sid?: Int;
}

export type UniqueIdType =
| { kind: 'ID' /* JSON: "id" */ }
| { kind: 'AST' }

export type CoreError = {
  rule_id?: RuleId;
  error_type: string;
  severity: CoreSeverity;
  location: Location;
  message: string;
  details?: string;
  yaml_path?: string[];
}

export type CoreSeverity =
| { kind: 'Error' /* JSON: "error" */ }
| { kind: 'Warning' /* JSON: "warning" */ }

export type CoreStats = {
  okfiles: Int;
  errorfiles: Int;
}

export type SkippedTarget = {
  path: string;
  reason: SkipReason;
  details: string;
  rule_id?: RuleId;
}

export type SkipReason =
| { kind: 'Excluded_by_config' /* JSON: "excluded_by_config" */ }
| { kind: 'Wrong_language' /* JSON: "wrong_language" */ }
| { kind: 'Too_big' /* JSON: "too_big" */ }
| { kind: 'Minified' /* JSON: "minified" */ }
| { kind: 'Binary' /* JSON: "binary" */ }
| { kind: 'Irrelevant_rule' /* JSON: "irrelevant_rule" */ }
| { kind: 'Too_many_matches' /* JSON: "too_many_matches" */ }

export type SkippedRule = {
  rule_id: RuleId;
  details: string;
  position: Position;
}

export type CoreTiming = {
  targets: TargetTime[];
  rules: RuleId[];
  rules_parse_time?: number;
}

export type TargetTime = {
  path: string;
  rule_times: RuleTimes[];
  run_time: number;
}

export type RuleTimes = {
  rule_id: RuleId;
  parse_time: number;
  match_time: number;
}

export type CveResult = {
  url: string;
  filename: string;
  funcnames: string[];
}

export type CveResults = CveResult[]

export type CoreMatchResults = {
  matches: CoreMatch[];
  errors: CoreError[];
  skipped_targets: SkippedTarget[];
  skipped_rules?: SkippedRule[];
  stats: CoreStats;
  time?: CoreTiming;
}

export type CliError = {
  code: Int;
  level: string;
  type_: string;
  rule_id?: RuleId;
  message?: string;
  path?: string;
  long_msg?: string;
  short_msg?: string;
  spans?: RawJson;
  help?: string;
}

export type CliMatch = {
  check_id: RuleId;
  path: string;
  start: Position;
  end: Position;
  extra: CliMatchExtra;
}

export type CliMatchExtra = {
  metavars?: Metavars;
  fingerprint: string;
  lines: string;
  message: string;
  metadata: RawJson;
  severity: string;
  fix?: string;
  fix_regex?: RawJson;
  is_ignored?: boolean;
  dependency_match_only?: boolean;
  dependency_matches?: RawJson;
}

export type CliOutput = {
  errors: CliError[];
  results: CliMatch[];
  paths: CliPaths;
  time?: CliTiming;
}

export type CliOutputExtra = {
  paths: CliPaths;
  time?: CliTiming;
}

export type CliPaths = {
  scanned: string[];
  _comment?: string;
  skipped?: CliSkippedTarget[];
}

export type CliSkippedTarget = {
  path: string;
  reason: string;
}

export type CliTiming = {
  rules: RuleIdDict[];
  rules_parse_time: number;
  profiling_times: [string, number][];
  targets: CliTargetTimes[];
  total_bytes: Int;
}

export type RuleIdDict = {
  id: RuleId;
}

export type CliTargetTimes = {
  path: string;
  num_bytes: Int;
  match_times: number[];
  parse_times: number[];
  run_time: number;
}

export function writeRawJson(x: RawJson, context: any = x): any {
  return writeAbstract(x, context);
}

export function readRawJson(x: any, context: any = x): RawJson {
  return readAbstract(x, context);
}

export function writePosition(x: Position, context: any = x): any {
  return {
    'line': _atd_write_required_field('Position', 'line', _atd_write_int, x.line, x),
    'col': _atd_write_required_field('Position', 'col', _atd_write_int, x.col, x),
    'offset': _atd_write_required_field('Position', 'offset', _atd_write_int, x.offset, x),
  };
}

export function readPosition(x: any, context: any = x): Position {
  return {
    line: _atd_read_required_field('Position', 'line', _atd_read_int, x['line'], x),
    col: _atd_read_required_field('Position', 'col', _atd_read_int, x['col'], x),
    offset: _atd_read_required_field('Position', 'offset', _atd_read_int, x['offset'], x),
  };
}

export function writeLocation(x: Location, context: any = x): any {
  return {
    'path': _atd_write_required_field('Location', 'path', _atd_write_string, x.path, x),
    'start': _atd_write_required_field('Location', 'start', writePosition, x.start, x),
    'end': _atd_write_required_field('Location', 'end', writePosition, x.end, x),
  };
}

export function readLocation(x: any, context: any = x): Location {
  return {
    path: _atd_read_required_field('Location', 'path', _atd_read_string, x['path'], x),
    start: _atd_read_required_field('Location', 'start', readPosition, x['start'], x),
    end: _atd_read_required_field('Location', 'end', readPosition, x['end'], x),
  };
}

export function writeRuleId(x: RuleId, context: any = x): any {
  return _atd_write_string(x, context);
}

export function readRuleId(x: any, context: any = x): RuleId {
  return _atd_read_string(x, context);
}

export function writeCoreMatch(x: CoreMatch, context: any = x): any {
  return {
    'rule_id': _atd_write_required_field('CoreMatch', 'rule_id', writeRuleId, x.rule_id, x),
    'location': _atd_write_required_field('CoreMatch', 'location', writeLocation, x.location, x),
    'extra': _atd_write_required_field('CoreMatch', 'extra', writeCoreMatchExtra, x.extra, x),
  };
}

export function readCoreMatch(x: any, context: any = x): CoreMatch {
  return {
    rule_id: _atd_read_required_field('CoreMatch', 'rule_id', readRuleId, x['rule_id'], x),
    location: _atd_read_required_field('CoreMatch', 'location', readLocation, x['location'], x),
    extra: _atd_read_required_field('CoreMatch', 'extra', readCoreMatchExtra, x['extra'], x),
  };
}

export function writeMetavars(x: Metavars, context: any = x): any {
  return _atd_write_assoc_array_to_object(writeMetavarValue)(x, context);
}

export function readMetavars(x: any, context: any = x): Metavars {
  return _atd_read_assoc_object_into_array(readMetavarValue)(x, context);
}

export function writeCoreMatchExtra(x: CoreMatchExtra, context: any = x): any {
  return {
    'message': _atd_write_optional_field(_atd_write_string, x.message, x),
    'metavars': _atd_write_required_field('CoreMatchExtra', 'metavars', writeMetavars, x.metavars, x),
  };
}

export function readCoreMatchExtra(x: any, context: any = x): CoreMatchExtra {
  return {
    message: _atd_read_optional_field(_atd_read_string, x['message'], x),
    metavars: _atd_read_required_field('CoreMatchExtra', 'metavars', readMetavars, x['metavars'], x),
  };
}

export function writeMetavarValue(x: MetavarValue, context: any = x): any {
  return {
    'start': _atd_write_required_field('MetavarValue', 'start', writePosition, x.start, x),
    'end': _atd_write_required_field('MetavarValue', 'end', writePosition, x.end, x),
    'abstract_content': _atd_write_required_field('MetavarValue', 'abstract_content', _atd_write_string, x.abstract_content, x),
    'propagated_value': _atd_write_optional_field(writeSvalueValue, x.propagated_value, x),
    'unique_id': _atd_write_required_field('MetavarValue', 'unique_id', writeUniqueId, x.unique_id, x),
  };
}

export function readMetavarValue(x: any, context: any = x): MetavarValue {
  return {
    start: _atd_read_required_field('MetavarValue', 'start', readPosition, x['start'], x),
    end: _atd_read_required_field('MetavarValue', 'end', readPosition, x['end'], x),
    abstract_content: _atd_read_required_field('MetavarValue', 'abstract_content', _atd_read_string, x['abstract_content'], x),
    propagated_value: _atd_read_optional_field(readSvalueValue, x['propagated_value'], x),
    unique_id: _atd_read_required_field('MetavarValue', 'unique_id', readUniqueId, x['unique_id'], x),
  };
}

export function writeSvalueValue(x: SvalueValue, context: any = x): any {
  return {
    'svalue_start': _atd_write_optional_field(writePosition, x.svalue_start, x),
    'svalue_end': _atd_write_optional_field(writePosition, x.svalue_end, x),
    'svalue_abstract_content': _atd_write_required_field('SvalueValue', 'svalue_abstract_content', _atd_write_string, x.svalue_abstract_content, x),
  };
}

export function readSvalueValue(x: any, context: any = x): SvalueValue {
  return {
    svalue_start: _atd_read_optional_field(readPosition, x['svalue_start'], x),
    svalue_end: _atd_read_optional_field(readPosition, x['svalue_end'], x),
    svalue_abstract_content: _atd_read_required_field('SvalueValue', 'svalue_abstract_content', _atd_read_string, x['svalue_abstract_content'], x),
  };
}

export function writeUniqueId(x: UniqueId, context: any = x): any {
  return {
    'type': _atd_write_required_field('UniqueId', 'type_', writeUniqueIdType, x.type_, x),
    'md5sum': _atd_write_optional_field(_atd_write_string, x.md5sum, x),
    'sid': _atd_write_optional_field(_atd_write_int, x.sid, x),
  };
}

export function readUniqueId(x: any, context: any = x): UniqueId {
  return {
    type_: _atd_read_required_field('UniqueId', 'type', readUniqueIdType, x['type'], x),
    md5sum: _atd_read_optional_field(_atd_read_string, x['md5sum'], x),
    sid: _atd_read_optional_field(_atd_read_int, x['sid'], x),
  };
}

export function writeUniqueIdType(x: UniqueIdType, context: any = x): any {
  switch (x.kind) {
    case 'ID':
      return 'id'
    case 'AST':
      return 'AST'
  }
}

export function readUniqueIdType(x: any, context: any = x): UniqueIdType {
  switch (x) {
    case 'id':
      return { kind: 'ID' }
    case 'AST':
      return { kind: 'AST' }
    default:
      _atd_bad_json('UniqueIdType', x, context)
      throw new Error('impossible')
  }
}

export function writeCoreError(x: CoreError, context: any = x): any {
  return {
    'rule_id': _atd_write_optional_field(writeRuleId, x.rule_id, x),
    'error_type': _atd_write_required_field('CoreError', 'error_type', _atd_write_string, x.error_type, x),
    'severity': _atd_write_required_field('CoreError', 'severity', writeCoreSeverity, x.severity, x),
    'location': _atd_write_required_field('CoreError', 'location', writeLocation, x.location, x),
    'message': _atd_write_required_field('CoreError', 'message', _atd_write_string, x.message, x),
    'details': _atd_write_optional_field(_atd_write_string, x.details, x),
    'yaml_path': _atd_write_optional_field(_atd_write_array(_atd_write_string), x.yaml_path, x),
  };
}

export function readCoreError(x: any, context: any = x): CoreError {
  return {
    rule_id: _atd_read_optional_field(readRuleId, x['rule_id'], x),
    error_type: _atd_read_required_field('CoreError', 'error_type', _atd_read_string, x['error_type'], x),
    severity: _atd_read_required_field('CoreError', 'severity', readCoreSeverity, x['severity'], x),
    location: _atd_read_required_field('CoreError', 'location', readLocation, x['location'], x),
    message: _atd_read_required_field('CoreError', 'message', _atd_read_string, x['message'], x),
    details: _atd_read_optional_field(_atd_read_string, x['details'], x),
    yaml_path: _atd_read_optional_field(_atd_read_array(_atd_read_string), x['yaml_path'], x),
  };
}

export function writeCoreSeverity(x: CoreSeverity, context: any = x): any {
  switch (x.kind) {
    case 'Error':
      return 'error'
    case 'Warning':
      return 'warning'
  }
}

export function readCoreSeverity(x: any, context: any = x): CoreSeverity {
  switch (x) {
    case 'error':
      return { kind: 'Error' }
    case 'warning':
      return { kind: 'Warning' }
    default:
      _atd_bad_json('CoreSeverity', x, context)
      throw new Error('impossible')
  }
}

export function writeCoreStats(x: CoreStats, context: any = x): any {
  return {
    'okfiles': _atd_write_required_field('CoreStats', 'okfiles', _atd_write_int, x.okfiles, x),
    'errorfiles': _atd_write_required_field('CoreStats', 'errorfiles', _atd_write_int, x.errorfiles, x),
  };
}

export function readCoreStats(x: any, context: any = x): CoreStats {
  return {
    okfiles: _atd_read_required_field('CoreStats', 'okfiles', _atd_read_int, x['okfiles'], x),
    errorfiles: _atd_read_required_field('CoreStats', 'errorfiles', _atd_read_int, x['errorfiles'], x),
  };
}

export function writeSkippedTarget(x: SkippedTarget, context: any = x): any {
  return {
    'path': _atd_write_required_field('SkippedTarget', 'path', _atd_write_string, x.path, x),
    'reason': _atd_write_required_field('SkippedTarget', 'reason', writeSkipReason, x.reason, x),
    'details': _atd_write_required_field('SkippedTarget', 'details', _atd_write_string, x.details, x),
    'rule_id': _atd_write_optional_field(writeRuleId, x.rule_id, x),
  };
}

export function readSkippedTarget(x: any, context: any = x): SkippedTarget {
  return {
    path: _atd_read_required_field('SkippedTarget', 'path', _atd_read_string, x['path'], x),
    reason: _atd_read_required_field('SkippedTarget', 'reason', readSkipReason, x['reason'], x),
    details: _atd_read_required_field('SkippedTarget', 'details', _atd_read_string, x['details'], x),
    rule_id: _atd_read_optional_field(readRuleId, x['rule_id'], x),
  };
}

export function writeSkipReason(x: SkipReason, context: any = x): any {
  switch (x.kind) {
    case 'Excluded_by_config':
      return 'excluded_by_config'
    case 'Wrong_language':
      return 'wrong_language'
    case 'Too_big':
      return 'too_big'
    case 'Minified':
      return 'minified'
    case 'Binary':
      return 'binary'
    case 'Irrelevant_rule':
      return 'irrelevant_rule'
    case 'Too_many_matches':
      return 'too_many_matches'
  }
}

export function readSkipReason(x: any, context: any = x): SkipReason {
  switch (x) {
    case 'excluded_by_config':
      return { kind: 'Excluded_by_config' }
    case 'wrong_language':
      return { kind: 'Wrong_language' }
    case 'too_big':
      return { kind: 'Too_big' }
    case 'minified':
      return { kind: 'Minified' }
    case 'binary':
      return { kind: 'Binary' }
    case 'irrelevant_rule':
      return { kind: 'Irrelevant_rule' }
    case 'too_many_matches':
      return { kind: 'Too_many_matches' }
    default:
      _atd_bad_json('SkipReason', x, context)
      throw new Error('impossible')
  }
}

export function writeSkippedRule(x: SkippedRule, context: any = x): any {
  return {
    'rule_id': _atd_write_required_field('SkippedRule', 'rule_id', writeRuleId, x.rule_id, x),
    'details': _atd_write_required_field('SkippedRule', 'details', _atd_write_string, x.details, x),
    'position': _atd_write_required_field('SkippedRule', 'position', writePosition, x.position, x),
  };
}

export function readSkippedRule(x: any, context: any = x): SkippedRule {
  return {
    rule_id: _atd_read_required_field('SkippedRule', 'rule_id', readRuleId, x['rule_id'], x),
    details: _atd_read_required_field('SkippedRule', 'details', _atd_read_string, x['details'], x),
    position: _atd_read_required_field('SkippedRule', 'position', readPosition, x['position'], x),
  };
}

export function writeCoreTiming(x: CoreTiming, context: any = x): any {
  return {
    'targets': _atd_write_required_field('CoreTiming', 'targets', _atd_write_array(writeTargetTime), x.targets, x),
    'rules': _atd_write_required_field('CoreTiming', 'rules', _atd_write_array(writeRuleId), x.rules, x),
    'rules_parse_time': _atd_write_optional_field(_atd_write_float, x.rules_parse_time, x),
  };
}

export function readCoreTiming(x: any, context: any = x): CoreTiming {
  return {
    targets: _atd_read_required_field('CoreTiming', 'targets', _atd_read_array(readTargetTime), x['targets'], x),
    rules: _atd_read_required_field('CoreTiming', 'rules', _atd_read_array(readRuleId), x['rules'], x),
    rules_parse_time: _atd_read_optional_field(_atd_read_float, x['rules_parse_time'], x),
  };
}

export function writeTargetTime(x: TargetTime, context: any = x): any {
  return {
    'path': _atd_write_required_field('TargetTime', 'path', _atd_write_string, x.path, x),
    'rule_times': _atd_write_required_field('TargetTime', 'rule_times', _atd_write_array(writeRuleTimes), x.rule_times, x),
    'run_time': _atd_write_required_field('TargetTime', 'run_time', _atd_write_float, x.run_time, x),
  };
}

export function readTargetTime(x: any, context: any = x): TargetTime {
  return {
    path: _atd_read_required_field('TargetTime', 'path', _atd_read_string, x['path'], x),
    rule_times: _atd_read_required_field('TargetTime', 'rule_times', _atd_read_array(readRuleTimes), x['rule_times'], x),
    run_time: _atd_read_required_field('TargetTime', 'run_time', _atd_read_float, x['run_time'], x),
  };
}

export function writeRuleTimes(x: RuleTimes, context: any = x): any {
  return {
    'rule_id': _atd_write_required_field('RuleTimes', 'rule_id', writeRuleId, x.rule_id, x),
    'parse_time': _atd_write_required_field('RuleTimes', 'parse_time', _atd_write_float, x.parse_time, x),
    'match_time': _atd_write_required_field('RuleTimes', 'match_time', _atd_write_float, x.match_time, x),
  };
}

export function readRuleTimes(x: any, context: any = x): RuleTimes {
  return {
    rule_id: _atd_read_required_field('RuleTimes', 'rule_id', readRuleId, x['rule_id'], x),
    parse_time: _atd_read_required_field('RuleTimes', 'parse_time', _atd_read_float, x['parse_time'], x),
    match_time: _atd_read_required_field('RuleTimes', 'match_time', _atd_read_float, x['match_time'], x),
  };
}

export function writeCveResult(x: CveResult, context: any = x): any {
  return {
    'url': _atd_write_required_field('CveResult', 'url', _atd_write_string, x.url, x),
    'filename': _atd_write_required_field('CveResult', 'filename', _atd_write_string, x.filename, x),
    'funcnames': _atd_write_required_field('CveResult', 'funcnames', _atd_write_array(_atd_write_string), x.funcnames, x),
  };
}

export function readCveResult(x: any, context: any = x): CveResult {
  return {
    url: _atd_read_required_field('CveResult', 'url', _atd_read_string, x['url'], x),
    filename: _atd_read_required_field('CveResult', 'filename', _atd_read_string, x['filename'], x),
    funcnames: _atd_read_required_field('CveResult', 'funcnames', _atd_read_array(_atd_read_string), x['funcnames'], x),
  };
}

export function writeCveResults(x: CveResults, context: any = x): any {
  return _atd_write_array(writeCveResult)(x, context);
}

export function readCveResults(x: any, context: any = x): CveResults {
  return _atd_read_array(readCveResult)(x, context);
}

export function writeCoreMatchResults(x: CoreMatchResults, context: any = x): any {
  return {
    'matches': _atd_write_required_field('CoreMatchResults', 'matches', _atd_write_array(writeCoreMatch), x.matches, x),
    'errors': _atd_write_required_field('CoreMatchResults', 'errors', _atd_write_array(writeCoreError), x.errors, x),
    'skipped': _atd_write_required_field('CoreMatchResults', 'skipped_targets', _atd_write_array(writeSkippedTarget), x.skipped_targets, x),
    'skipped_rules': _atd_write_optional_field(_atd_write_array(writeSkippedRule), x.skipped_rules, x),
    'stats': _atd_write_required_field('CoreMatchResults', 'stats', writeCoreStats, x.stats, x),
    'time': _atd_write_optional_field(writeCoreTiming, x.time, x),
  };
}

export function readCoreMatchResults(x: any, context: any = x): CoreMatchResults {
  return {
    matches: _atd_read_required_field('CoreMatchResults', 'matches', _atd_read_array(readCoreMatch), x['matches'], x),
    errors: _atd_read_required_field('CoreMatchResults', 'errors', _atd_read_array(readCoreError), x['errors'], x),
    skipped_targets: _atd_read_required_field('CoreMatchResults', 'skipped', _atd_read_array(readSkippedTarget), x['skipped'], x),
    skipped_rules: _atd_read_optional_field(_atd_read_array(readSkippedRule), x['skipped_rules'], x),
    stats: _atd_read_required_field('CoreMatchResults', 'stats', readCoreStats, x['stats'], x),
    time: _atd_read_optional_field(readCoreTiming, x['time'], x),
  };
}

export function writeCliError(x: CliError, context: any = x): any {
  return {
    'code': _atd_write_required_field('CliError', 'code', _atd_write_int, x.code, x),
    'level': _atd_write_required_field('CliError', 'level', _atd_write_string, x.level, x),
    'type': _atd_write_required_field('CliError', 'type_', _atd_write_string, x.type_, x),
    'rule_id': _atd_write_optional_field(writeRuleId, x.rule_id, x),
    'message': _atd_write_optional_field(_atd_write_string, x.message, x),
    'path': _atd_write_optional_field(_atd_write_string, x.path, x),
    'long_msg': _atd_write_optional_field(_atd_write_string, x.long_msg, x),
    'short_msg': _atd_write_optional_field(_atd_write_string, x.short_msg, x),
    'spans': _atd_write_optional_field(writeRawJson, x.spans, x),
    'help': _atd_write_optional_field(_atd_write_string, x.help, x),
  };
}

export function readCliError(x: any, context: any = x): CliError {
  return {
    code: _atd_read_required_field('CliError', 'code', _atd_read_int, x['code'], x),
    level: _atd_read_required_field('CliError', 'level', _atd_read_string, x['level'], x),
    type_: _atd_read_required_field('CliError', 'type', _atd_read_string, x['type'], x),
    rule_id: _atd_read_optional_field(readRuleId, x['rule_id'], x),
    message: _atd_read_optional_field(_atd_read_string, x['message'], x),
    path: _atd_read_optional_field(_atd_read_string, x['path'], x),
    long_msg: _atd_read_optional_field(_atd_read_string, x['long_msg'], x),
    short_msg: _atd_read_optional_field(_atd_read_string, x['short_msg'], x),
    spans: _atd_read_optional_field(readRawJson, x['spans'], x),
    help: _atd_read_optional_field(_atd_read_string, x['help'], x),
  };
}

export function writeCliMatch(x: CliMatch, context: any = x): any {
  return {
    'check_id': _atd_write_required_field('CliMatch', 'check_id', writeRuleId, x.check_id, x),
    'path': _atd_write_required_field('CliMatch', 'path', _atd_write_string, x.path, x),
    'start': _atd_write_required_field('CliMatch', 'start', writePosition, x.start, x),
    'end': _atd_write_required_field('CliMatch', 'end', writePosition, x.end, x),
    'extra': _atd_write_required_field('CliMatch', 'extra', writeCliMatchExtra, x.extra, x),
  };
}

export function readCliMatch(x: any, context: any = x): CliMatch {
  return {
    check_id: _atd_read_required_field('CliMatch', 'check_id', readRuleId, x['check_id'], x),
    path: _atd_read_required_field('CliMatch', 'path', _atd_read_string, x['path'], x),
    start: _atd_read_required_field('CliMatch', 'start', readPosition, x['start'], x),
    end: _atd_read_required_field('CliMatch', 'end', readPosition, x['end'], x),
    extra: _atd_read_required_field('CliMatch', 'extra', readCliMatchExtra, x['extra'], x),
  };
}

export function writeCliMatchExtra(x: CliMatchExtra, context: any = x): any {
  return {
    'metavars': _atd_write_optional_field(writeMetavars, x.metavars, x),
    'fingerprint': _atd_write_required_field('CliMatchExtra', 'fingerprint', _atd_write_string, x.fingerprint, x),
    'lines': _atd_write_required_field('CliMatchExtra', 'lines', _atd_write_string, x.lines, x),
    'message': _atd_write_required_field('CliMatchExtra', 'message', _atd_write_string, x.message, x),
    'metadata': _atd_write_required_field('CliMatchExtra', 'metadata', writeRawJson, x.metadata, x),
    'severity': _atd_write_required_field('CliMatchExtra', 'severity', _atd_write_string, x.severity, x),
    'fix': _atd_write_optional_field(_atd_write_string, x.fix, x),
    'fix_regex': _atd_write_optional_field(writeRawJson, x.fix_regex, x),
    'is_ignored': _atd_write_optional_field(_atd_write_bool, x.is_ignored, x),
    'dependency_match_only': _atd_write_optional_field(_atd_write_bool, x.dependency_match_only, x),
    'dependency_matches': _atd_write_optional_field(writeRawJson, x.dependency_matches, x),
  };
}

export function readCliMatchExtra(x: any, context: any = x): CliMatchExtra {
  return {
    metavars: _atd_read_optional_field(readMetavars, x['metavars'], x),
    fingerprint: _atd_read_required_field('CliMatchExtra', 'fingerprint', _atd_read_string, x['fingerprint'], x),
    lines: _atd_read_required_field('CliMatchExtra', 'lines', _atd_read_string, x['lines'], x),
    message: _atd_read_required_field('CliMatchExtra', 'message', _atd_read_string, x['message'], x),
    metadata: _atd_read_required_field('CliMatchExtra', 'metadata', readRawJson, x['metadata'], x),
    severity: _atd_read_required_field('CliMatchExtra', 'severity', _atd_read_string, x['severity'], x),
    fix: _atd_read_optional_field(_atd_read_string, x['fix'], x),
    fix_regex: _atd_read_optional_field(readRawJson, x['fix_regex'], x),
    is_ignored: _atd_read_optional_field(_atd_read_bool, x['is_ignored'], x),
    dependency_match_only: _atd_read_optional_field(_atd_read_bool, x['dependency_match_only'], x),
    dependency_matches: _atd_read_optional_field(readRawJson, x['dependency_matches'], x),
  };
}

export function writeCliOutput(x: CliOutput, context: any = x): any {
  return {
    'errors': _atd_write_required_field('CliOutput', 'errors', _atd_write_array(writeCliError), x.errors, x),
    'results': _atd_write_required_field('CliOutput', 'results', _atd_write_array(writeCliMatch), x.results, x),
    'paths': _atd_write_required_field('CliOutput', 'paths', writeCliPaths, x.paths, x),
    'time': _atd_write_optional_field(writeCliTiming, x.time, x),
  };
}

export function readCliOutput(x: any, context: any = x): CliOutput {
  return {
    errors: _atd_read_required_field('CliOutput', 'errors', _atd_read_array(readCliError), x['errors'], x),
    results: _atd_read_required_field('CliOutput', 'results', _atd_read_array(readCliMatch), x['results'], x),
    paths: _atd_read_required_field('CliOutput', 'paths', readCliPaths, x['paths'], x),
    time: _atd_read_optional_field(readCliTiming, x['time'], x),
  };
}

export function writeCliOutputExtra(x: CliOutputExtra, context: any = x): any {
  return {
    'paths': _atd_write_required_field('CliOutputExtra', 'paths', writeCliPaths, x.paths, x),
    'time': _atd_write_optional_field(writeCliTiming, x.time, x),
  };
}

export function readCliOutputExtra(x: any, context: any = x): CliOutputExtra {
  return {
    paths: _atd_read_required_field('CliOutputExtra', 'paths', readCliPaths, x['paths'], x),
    time: _atd_read_optional_field(readCliTiming, x['time'], x),
  };
}

export function writeCliPaths(x: CliPaths, context: any = x): any {
  return {
    'scanned': _atd_write_required_field('CliPaths', 'scanned', _atd_write_array(_atd_write_string), x.scanned, x),
    '_comment': _atd_write_optional_field(_atd_write_string, x._comment, x),
    'skipped': _atd_write_optional_field(_atd_write_array(writeCliSkippedTarget), x.skipped, x),
  };
}

export function readCliPaths(x: any, context: any = x): CliPaths {
  return {
    scanned: _atd_read_required_field('CliPaths', 'scanned', _atd_read_array(_atd_read_string), x['scanned'], x),
    _comment: _atd_read_optional_field(_atd_read_string, x['_comment'], x),
    skipped: _atd_read_optional_field(_atd_read_array(readCliSkippedTarget), x['skipped'], x),
  };
}

export function writeCliSkippedTarget(x: CliSkippedTarget, context: any = x): any {
  return {
    'path': _atd_write_required_field('CliSkippedTarget', 'path', _atd_write_string, x.path, x),
    'reason': _atd_write_required_field('CliSkippedTarget', 'reason', _atd_write_string, x.reason, x),
  };
}

export function readCliSkippedTarget(x: any, context: any = x): CliSkippedTarget {
  return {
    path: _atd_read_required_field('CliSkippedTarget', 'path', _atd_read_string, x['path'], x),
    reason: _atd_read_required_field('CliSkippedTarget', 'reason', _atd_read_string, x['reason'], x),
  };
}

export function writeCliTiming(x: CliTiming, context: any = x): any {
  return {
    'rules': _atd_write_required_field('CliTiming', 'rules', _atd_write_array(writeRuleIdDict), x.rules, x),
    'rules_parse_time': _atd_write_required_field('CliTiming', 'rules_parse_time', _atd_write_float, x.rules_parse_time, x),
    'profiling_times': _atd_write_required_field('CliTiming', 'profiling_times', _atd_write_assoc_array_to_object(_atd_write_float), x.profiling_times, x),
    'targets': _atd_write_required_field('CliTiming', 'targets', _atd_write_array(writeCliTargetTimes), x.targets, x),
    'total_bytes': _atd_write_required_field('CliTiming', 'total_bytes', _atd_write_int, x.total_bytes, x),
  };
}

export function readCliTiming(x: any, context: any = x): CliTiming {
  return {
    rules: _atd_read_required_field('CliTiming', 'rules', _atd_read_array(readRuleIdDict), x['rules'], x),
    rules_parse_time: _atd_read_required_field('CliTiming', 'rules_parse_time', _atd_read_float, x['rules_parse_time'], x),
    profiling_times: _atd_read_required_field('CliTiming', 'profiling_times', _atd_read_assoc_object_into_array(_atd_read_float), x['profiling_times'], x),
    targets: _atd_read_required_field('CliTiming', 'targets', _atd_read_array(readCliTargetTimes), x['targets'], x),
    total_bytes: _atd_read_required_field('CliTiming', 'total_bytes', _atd_read_int, x['total_bytes'], x),
  };
}

export function writeRuleIdDict(x: RuleIdDict, context: any = x): any {
  return {
    'id': _atd_write_required_field('RuleIdDict', 'id', writeRuleId, x.id, x),
  };
}

export function readRuleIdDict(x: any, context: any = x): RuleIdDict {
  return {
    id: _atd_read_required_field('RuleIdDict', 'id', readRuleId, x['id'], x),
  };
}

export function writeCliTargetTimes(x: CliTargetTimes, context: any = x): any {
  return {
    'path': _atd_write_required_field('CliTargetTimes', 'path', _atd_write_string, x.path, x),
    'num_bytes': _atd_write_required_field('CliTargetTimes', 'num_bytes', _atd_write_int, x.num_bytes, x),
    'match_times': _atd_write_required_field('CliTargetTimes', 'match_times', _atd_write_array(_atd_write_float), x.match_times, x),
    'parse_times': _atd_write_required_field('CliTargetTimes', 'parse_times', _atd_write_array(_atd_write_float), x.parse_times, x),
    'run_time': _atd_write_required_field('CliTargetTimes', 'run_time', _atd_write_float, x.run_time, x),
  };
}

export function readCliTargetTimes(x: any, context: any = x): CliTargetTimes {
  return {
    path: _atd_read_required_field('CliTargetTimes', 'path', _atd_read_string, x['path'], x),
    num_bytes: _atd_read_required_field('CliTargetTimes', 'num_bytes', _atd_read_int, x['num_bytes'], x),
    match_times: _atd_read_required_field('CliTargetTimes', 'match_times', _atd_read_array(_atd_read_float), x['match_times'], x),
    parse_times: _atd_read_required_field('CliTargetTimes', 'parse_times', _atd_read_array(_atd_read_float), x['parse_times'], x),
    run_time: _atd_read_required_field('CliTargetTimes', 'run_time', _atd_read_float, x['run_time'], x),
  };
}


/////////////////////////////////////////////////////////////////////
// Runtime library
/////////////////////////////////////////////////////////////////////

export type Int = number

export type Option<T> = null | { value: T }

function _atd_missing_json_field(type_name: string, json_field_name: string) {
    throw new Error(`missing field '${json_field_name}'` +
                    ` in JSON object of type '${type_name}'`)
}

function _atd_missing_ts_field(type_name: string, ts_field_name: string) {
    throw new Error(`missing field '${ts_field_name}'` +
                    ` in TypeScript object of type '${type_name}'`)
}

function _atd_bad_json(expected_type: string, json_value: any, context: any) {
  let value_str = JSON.stringify(json_value)
  if (value_str.length > 200)
    value_str = value_str.substring(0, 200) + '…';

  throw new Error(`incompatible JSON value where` +
                  ` type '${expected_type}' was expected: '${value_str}'.` +
                  ` Occurs in '${JSON.stringify(context)}'.`)
}

function _atd_bad_ts(expected_type: string, ts_value: any, context: any) {
  let value_str = JSON.stringify(ts_value)
  if (value_str.length > 200)
    value_str = value_str.substring(0, 200) + '…';

  throw new Error(`incompatible TypeScript value where` +
                  ` type '${expected_type}' was expected: '${value_str}'.` +
                  ` Occurs in '${JSON.stringify(context)}'.`)
}

function _atd_check_json_tuple(len: Int, x: any, context: any) {
  if (! Array.isArray(x) || x.length !== len)
    _atd_bad_json('tuple of length ' + len, x, context);
}

function _atd_read_unit(x: any, context: any): null {
  if (x === null)
    return null
  else {
    _atd_bad_json('null', x, context)
    throw new Error('impossible')
  }
}

function _atd_read_bool(x: any, context: any): boolean {
  if (typeof x === 'boolean')
    return x
  else {
    _atd_bad_json('boolean', x, context)
    throw new Error('impossible')
  }
}

function _atd_read_int(x: any, context: any): Int {
  if (Number.isInteger(x))
    return x
  else {
    _atd_bad_json('integer', x, context)
    throw new Error('impossible')
  }
}

function _atd_read_float(x: any, context: any): number {
  if (isFinite(x))
    return x
  else {
    _atd_bad_json('number', x, context)
    throw new Error('impossible')
  }
}

function _atd_read_string(x: any, context: any): string {
  if (typeof x === 'string')
    return x
  else {
    _atd_bad_json('string', x, context)
    throw new Error('impossible')
  }
}

function _atd_read_required_field<T>(type_name: string,
                                     field_name: string,
                                     read_elt: (x: any, context: any) => T,
                                     x: any,
                                     context: any): T {
  if (x === undefined) {
    _atd_missing_json_field(type_name, field_name)
    throw new Error('impossible')
  }
  else
    return read_elt(x, context)
}

function _atd_read_optional_field<T>(read_elt: (x: any, context: any) => T,
                                     x: any,
                                     context: any): T {
  if (x === undefined || x === null)
    return x
  else
    return read_elt(x, context)
}

function _atd_read_field_with_default<T>(read_elt: (x: any, context: any) => T,
                                         default_: T,
                                         x: any,
                                         context: any): T {
  if (x === undefined || x === null)
    return default_
  else
    return read_elt(x, context)
}

function _atd_read_option<T>(read_elt: (x: any, context: any) => T):
  (x: any, context: any) => Option<T> {
  function read_option(x: any, context: any): Option<T> {
    if (x === 'None')
      return null
    else {
      _atd_check_json_tuple(2, x, context);
      switch (x[0]) {
        case 'Some':
          return { value: read_elt(x[1], context) }
        default:
          _atd_bad_json('option', x, context)
          throw new Error('impossible')
      }
    }
  }
  return read_option
}

function _atd_read_nullable<T>(read_elt: (x: any, context: any) => T):
  (x: any, context: any) => T | null {
  function read_nullable(x: any, context: any): T | null {
    if (x === null)
      return null
    else
      return read_elt(x, context)
  }
  return read_nullable
}

function _atd_read_array<T>(read_elt: (x: any, context: any) => T):
  (elts: any, context: any) => T[] {
  function read_array(elts: any, context: any): T[] {
    if (Array.isArray(elts))
      return elts.map((x) => read_elt(x, elts))
    else {
      _atd_bad_json('array', elts, context)
      throw new Error('impossible')
    }
  }
  return read_array
}

function _atd_read_assoc_array_into_map<K, V>(
    read_key: (key: any, context: any) => K,
    read_value: (value: any, context: any) => V
  ): (x: any, context: any) => Map<K, V> {
  function read_assoc(elts: any, context: any): Map<K, V> {
    if (Array.isArray(elts)) {
      const res = new Map<K, V>([])
      for (const x of elts) {
        if (Array.isArray(x) && x.length === 2)
          res.set(read_key(x[0], x), read_value(x[1], x))
        else {
          _atd_bad_json('pair', x, elts)
          throw new Error('impossible')
        }
      }
      return res
    }
    else {
      _atd_bad_json('array', elts, context)
      throw new Error('impossible')
    }
  }
  return read_assoc
}

function _atd_read_assoc_object_into_map<T>(
    read_value: (value: any, context: any) => T
  ): (x: any, context: any) => Map<string, T> {
  function read_assoc(elts: any, context: any): Map<string, T> {
    if (typeof elts === 'object') {
      const res = new Map<string, T>([])
      for (const [key, value] of Object.entries(elts))
        res.set(key, read_value(value, elts))
      return res
    }
    else {
      _atd_bad_json('object', elts, context)
      throw new Error('impossible')
    }
  }
  return read_assoc
}

function _atd_read_assoc_object_into_array<T>(
    read_value: (value: any, context: any) => T
  ): (x: any, context: any) => [string, T][] {
  function read_assoc(elts: any, context: any): [string, T][] {
    if (typeof elts === 'object') {
      const res: [string, T][] = []
      for (const [key, value] of Object.entries(elts))
        res.push([key, read_value(value, elts)])
      return res
    }
    else {
      _atd_bad_json('object', elts, context)
      throw new Error('impossible')
    }
  }
  return read_assoc
}

function _atd_write_unit(x: any, context: any) {
  if (x === null)
    return x
  else {
    _atd_bad_ts('null', x, context)
    throw new Error('impossible')
  }
}

function _atd_write_bool(x: any, context: any): boolean {
  if (typeof x === 'boolean')
    return x
  else {
    _atd_bad_ts('boolean', x, context)
    throw new Error('impossible')
  }
}

function _atd_write_int(x: any, context: any): Int {
  if (Number.isInteger(x))
    return x
  else {
    _atd_bad_ts('integer', x, context)
    throw new Error('impossible')
  }
}

function _atd_write_float(x: any, context: any): number {
  if (isFinite(x))
    return x
  else {
    _atd_bad_ts('number', x, context)
    throw new Error('impossible')
  }
}

function _atd_write_string(x: any, context: any): string {
  if (typeof x === 'string')
    return x
  else {
    _atd_bad_ts('string', x, context)
    throw new Error('impossible')
  }
}

function _atd_write_option<T>(write_elt: (x: T, context: any) => any):
   (elts: Option<T>, context: any) => any {
  function write_option(x: Option<T>, context: any): any {
    if (x === null)
      return 'None'
    else
      return ['Some', write_elt(x.value, context)]
  }
  return write_option
}

function _atd_write_nullable<T>(write_elt: (x: T | null, context: any) => any):
  (x: T | null, context: any) => any {
  function write_option(x: T | null, context: any): any {
    if (x === null)
      return null
    else
      return write_elt(x, context)
  }
  return write_option
}

function _atd_write_array<T>(write_elt: (elt: T, context: any) => any):
  (elts: T[], context: any) => any {
  return ((elts: T[], context: any): any =>
    elts.map((x) => write_elt(x, elts))
  )
}

function _atd_write_assoc_map_to_array<K, V>(
    write_key: (key: K, context: any) => any,
    write_value: (value: V, context: any) => any
  ): (elts: Map<K, V>, context: any) => any {
  function write_assoc(elts: Map<K, V>, context: any): any {
    const res: any = []
    elts.forEach((value: V, key: K) =>
      res.push([write_key(key, elts), write_value(value, elts)])
    )
    return res
  }
  return write_assoc
}

function _atd_write_assoc_map_to_object<T>(
    write_value: (value: T, context: any) => any
  ): (elts: Map<string, T>, context: any) => any {
  function write_assoc(elts: Map<string, T>, context: any): any {
    const res: any = {}
    elts.forEach((value: T, key: string) =>
      res[key] = write_value(value, elts)
    )
    return res
  }
  return write_assoc
}

function _atd_write_assoc_array_to_object<T>(
    write_value: (value: T, context: any) => any
  ): (elts: [string, T][], context: any) => any {
  function write_assoc(elts: [string, T][], context: any): any {
    const res: any = {}
    for (const [key, value] of elts)
      res[key] = write_value(value, elts)
    return res
  }
  return write_assoc
}

function _atd_write_required_field<T>(type_name: string,
                                      field_name: string,
                                      write_elt: (x: T, context: any) => any,
                                      x: T,
                                      context: any): any {
  if (x === undefined) {
    _atd_missing_ts_field(type_name, field_name)
    throw new Error('impossible')
  }
  else
    return write_elt(x, context)
}

function _atd_write_optional_field<T>(write_elt: (x: T, context: any) => any,
                                      x: T,
                                      context: any): any {
  if (x === undefined || x === null)
    return x
  else
    return write_elt(x, context)
}

function _atd_write_field_with_default<T>(
  write_elt: (x: T, context: any) => any,
  default_: T,
  x: T,
  context: any
): T {
  const value = (x === undefined || x === null) ? default_ : x
  return write_elt(value, context)
}

