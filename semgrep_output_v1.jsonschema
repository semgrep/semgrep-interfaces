{
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "title": "cli_output",
  "description": "Translated by atdcat from 'semgrep_output_v1.atd'.",
  "type": "object",
  "required": [ "results", "errors", "paths" ],
  "properties": {
    "version": { "description": "", "$ref": "#/definitions/version" },
    "results": {
      "type": "array",
      "items": { "$ref": "#/definitions/cli_match" }
    },
    "errors": {
      "type": "array",
      "items": { "$ref": "#/definitions/cli_error" }
    },
    "paths": {
      "description": "",
      "$ref": "#/definitions/scanned_and_skipped"
    },
    "time": { "description": "", "$ref": "#/definitions/profile" },
    "explanations": {
      "description": "",
      "type": "array",
      "items": { "$ref": "#/definitions/matching_explanation" }
    },
    "rules_by_engine": {
      "description": "",
      "type": "array",
      "items": { "$ref": "#/definitions/rule_id_and_engine_kind" }
    },
    "engine_requested": { "$ref": "#/definitions/engine_kind" },
    "interfile_languages_used": {
      "description": "",
      "type": "array",
      "items": { "type": "string" }
    },
    "skipped_rules": {
      "description": "",
      "type": "array",
      "items": { "$ref": "#/definitions/skipped_rule" }
    },
    "subprojects": {
      "description": "",
      "type": "array",
      "items": { "$ref": "#/definitions/cli_output_subproject_info" }
    },
    "mcp_scan_results": {
      "description": "",
      "$ref": "#/definitions/mcp_scan_results"
    },
    "profiling_results": {
      "description": "",
      "type": "array",
      "items": { "$ref": "#/definitions/profiling_entry" }
    }
  },
  "definitions": {
    "raw_json": { "description": "escape hatch" },
    "fpath": { "type": "string" },
    "ppath": { "type": "string" },
    "fppath": {
      "description": "Same as Fppath.t: a nice filesystem path + the path relative to the project root provided for pattern-based filtering purposes.",
      "type": "object",
      "required": [ "fpath", "ppath" ],
      "properties": {
        "fpath": { "$ref": "#/definitions/fpath" },
        "ppath": { "$ref": "#/definitions/ppath" }
      }
    },
    "uri": { "type": "string" },
    "sha1": { "type": "string" },
    "uuid": { "type": "string" },
    "datetime": { "description": "RFC 3339 format", "type": "string" },
    "glob": { "type": "string" },
    "version": { "description": "e.g., '1.1.0'", "type": "string" },
    "position": {
      "description": "Note that there is no filename here like in 'location' below",
      "type": "object",
      "required": [ "line", "col" ],
      "properties": {
        "line": { "type": "integer" },
        "col": { "type": "integer" },
        "offset": {
          "description": "Byte position from the beginning of the file, starts at 0. OCaml code sets it correctly. Python code sets it to a dummy value (-1). This uses '~' because pysemgrep < 1.30? was *producing* positions without offset sometimes, and we want the backend to still *consume* such positions. Note that pysemgrep 1.97 was still producing dummy positions without an offset so we might need this ~offset longer than expected?",
          "type": "integer"
        }
      }
    },
    "location": {
      "type": "object",
      "required": [ "path", "start", "end" ],
      "properties": {
        "path": { "$ref": "#/definitions/fpath" },
        "start": { "$ref": "#/definitions/position" },
        "end": { "$ref": "#/definitions/position" }
      }
    },
    "rule_id": {
      "description": "e.g., \"javascript.security.do-not-use-eval\"",
      "type": "string"
    },
    "match_severity": {
      "description": "This is used in rules to specify the severity of matches/findings. alt: could be called rule_severity, or finding_severity.\n\n{{{\n   Error = something wrong that must be fixed\n   Warning = something wrong that should be fixed\n   Info = some special condition worth knowing about\n   Experiment = deprecated: guess what\n   Inventory = deprecated: was used for the Code Asset Inventory (CAI) project\n}}}",
      "oneOf": [
        { "const": "ERROR" },
        { "const": "WARNING" },
        { "const": "EXPERIMENT" },
        { "const": "INVENTORY" },
        {
          "description": "since 1.72.0, meant to replace the cases above where Error -> High, Warning -> Medium. Critical/Low are the only really new category here without equivalent before. Experiment and Inventory above should be removed. Info can be kept.",
          "const": "CRITICAL"
        },
        { "const": "HIGH" },
        { "const": "MEDIUM" },
        { "const": "LOW" },
        {
          "description": "generic placeholder for non-risky things (including experiments)",
          "const": "INFO"
        }
      ]
    },
    "error_severity": {
      "description": "This is used to specify the severity of errors which happened during Semgrep execution (e.g., a parse error).\n\n{{{\n    Error = Always an error\n    Warning = Only an error if \"strict\" is set\n    Info = Nothing may be wrong\n}}}\n\nalt: could reuse match_severity but seems cleaner to define its own type",
      "oneOf": [
        { "const": "error" }, { "const": "warn" }, { "const": "info" }
      ]
    },
    "pro_feature": {
      "description": "Used for a best-effort report to users about what findings they get with the pro engine that they couldn't with the oss engine.\n\n{{{\n    interproc_taint = requires interprocedural taint\n    interfile_taint = requires interfile taint\n    proprietary_language = requires some non-taint pro feature\n}}}",
      "type": "object",
      "required": [
        "interproc_taint", "interfile_taint", "proprietary_language"
      ],
      "properties": {
        "interproc_taint": { "type": "boolean" },
        "interfile_taint": { "type": "boolean" },
        "proprietary_language": { "type": "boolean" }
      }
    },
    "engine_of_finding": {
      "description": "Report the engine used to detect each finding. Additionally, if we are able to infer that the finding could only be detected using the pro engine, report that the pro engine is required and include basic information about which feature is required.\n\n{{{\n   OSS = ran with OSS\n   PRO = ran with PRO, but we didn't infer that OSS couldn't have found this\n   finding\n   PRO_REQUIRED = ran with PRO and requires a PRO feature (see pro_feature_used)\n}}}\n\nNote: OSS and PRO could have clearer names, but for backwards compatibility we're leaving them as is",
      "oneOf": [
        { "const": "OSS" },
        { "const": "PRO" },
        {
          "type": "array",
          "minItems": 2,
          "items": false,
          "prefixItems": [
            {
              "description": "Semgrep 1.64.0 or later",
              "const": "PRO_REQUIRED"
            },
            { "$ref": "#/definitions/pro_feature" }
          ]
        }
      ]
    },
    "engine_kind": { "oneOf": [ { "const": "OSS" }, { "const": "PRO" } ] },
    "rule_id_and_engine_kind": {
      "type": "array",
      "minItems": 2,
      "items": false,
      "prefixItems": [
        { "$ref": "#/definitions/rule_id" },
        { "$ref": "#/definitions/engine_kind" }
      ]
    },
    "product": {
      "oneOf": [
        { "description": "a.k.a. Code", "const": "sast" },
        { "description": "a.k.a. SSC", "const": "sca" },
        { "const": "secrets" }
      ]
    },
    "match_based_id": { "description": "e.g. \"ab023_1\"", "type": "string" },
    "cli_match": {
      "type": "object",
      "required": [ "check_id", "path", "start", "end", "extra" ],
      "properties": {
        "check_id": { "$ref": "#/definitions/rule_id" },
        "path": { "$ref": "#/definitions/fpath" },
        "start": { "$ref": "#/definitions/position" },
        "end": { "$ref": "#/definitions/position" },
        "extra": { "$ref": "#/definitions/cli_match_extra" }
      }
    },
    "cli_match_extra": {
      "type": "object",
      "required": [
        "message", "metadata", "severity", "fingerprint", "lines"
      ],
      "properties": {
        "metavars": {
          "description": "Since 1.98.0, you need to be logged in to get this field. note: we also need ?metavars because dependency_aware code",
          "$ref": "#/definitions/metavars"
        },
        "message": {
          "description": "Those fields are derived from the rule but the metavariables they contain have been expanded to their concrete value.",
          "type": "string"
        },
        "fix": {
          "description": "If present, semgrep was able to compute a string that should be inserted in place of the text in the matched range in order to fix the finding. Note that this is the result of applying both the fix: or fix_regex: in a rule.",
          "type": "string"
        },
        "fixed_lines": { "type": "array", "items": { "type": "string" } },
        "metadata": {
          "description": "fields coming from the rule",
          "$ref": "#/definitions/raw_json"
        },
        "severity": { "$ref": "#/definitions/match_severity" },
        "fingerprint": {
          "description": "Since 1.98.0, you need to be logged in to get those fields",
          "type": "string"
        },
        "lines": { "type": "string" },
        "is_ignored": { "description": "for nosemgrep", "type": "boolean" },
        "sca_info": {
          "description": "EXPERIMENTAL: added by dependency_aware code",
          "$ref": "#/definitions/sca_match"
        },
        "validation_state": {
          "description": "EXPERIMENTAL: If present indicates the status of postprocessor validation. This field not being present should be equivalent to No_validator. Added in semgrep 1.37.0",
          "$ref": "#/definitions/validation_state"
        },
        "historical_info": {
          "description": "EXPERIMENTAL: added by secrets post-processing & historical scanning code Since 1.60.0.",
          "$ref": "#/definitions/historical_info"
        },
        "dataflow_trace": {
          "description": "EXPERIMENTAL: For now, present only for taint findings. May be extended to others later on.",
          "$ref": "#/definitions/match_dataflow_trace"
        },
        "engine_kind": { "$ref": "#/definitions/engine_of_finding" },
        "extra_extra": {
          "description": "EXPERIMENTAL: see core_match_extra.extra_extra",
          "$ref": "#/definitions/raw_json"
        }
      }
    },
    "metavars": {
      "description": "Name/value map of the matched metavariables. The leading '$' must be included in the metavariable name.",
      "type": "object",
      "additionalProperties": { "$ref": "#/definitions/metavar_value" }
    },
    "metavar_value": {
      "type": "object",
      "required": [ "start", "end", "abstract_content" ],
      "properties": {
        "start": {
          "description": "for certain metavariable like $...ARGS, 'end' may be equal to 'start' to represent an empty metavariable value. The rest of the Python code (message metavariable substitution and autofix) works without change for empty ranges (when end = start).",
          "$ref": "#/definitions/position"
        },
        "end": { "$ref": "#/definitions/position" },
        "abstract_content": { "description": "value?", "type": "string" },
        "propagated_value": { "$ref": "#/definitions/svalue_value" }
      }
    },
    "svalue_value": {
      "type": "object",
      "required": [ "svalue_abstract_content" ],
      "properties": {
        "svalue_start": { "$ref": "#/definitions/position" },
        "svalue_end": { "$ref": "#/definitions/position" },
        "svalue_abstract_content": {
          "description": "value?",
          "type": "string"
        }
      }
    },
    "matching_explanation": {
      "description": "EXPERIMENTAL",
      "type": "object",
      "required": [ "op", "children", "matches", "loc" ],
      "properties": {
        "op": { "$ref": "#/definitions/matching_operation" },
        "children": {
          "type": "array",
          "items": { "$ref": "#/definitions/matching_explanation" }
        },
        "matches": {
          "description": "result matches at this node (can be empty when we reach a nomatch)",
          "type": "array",
          "items": { "$ref": "#/definitions/core_match" }
        },
        "loc": {
          "description": "location in the rule file! not target file. This tries to delimit the part of the rule relevant to the current operation (e.g., the position of the 'patterns:' token in the rule for the And operation).",
          "$ref": "#/definitions/location"
        },
        "extra": {
          "description": "NEW: since v1.79",
          "$ref": "#/definitions/matching_explanation_extra"
        }
      }
    },
    "matching_explanation_extra": {
      "description": "For any \"extra\" information that we cannot fit at the node itself. This is useful for kind-specific information, which we cannot put in the operation itself without giving up our ability to derive `show` (needed for `matching_operation` below).",
      "type": "object",
      "required": [ "before_negation_matches", "before_filter_matches" ],
      "properties": {
        "before_negation_matches": {
          "description": "Only present in And kind. This information is useful for determining the input matches to the first Negation node.",
          "oneOf": [
            {
              "type": "array",
              "minItems": 2,
              "items": false,
              "prefixItems": [
                { "const": "Some" },
                {
                  "type": "array",
                  "items": { "$ref": "#/definitions/core_match" }
                }
              ]
            },
            { "const": "None" }
          ]
        },
        "before_filter_matches": {
          "description": "Only present in nodes which have children Filter nodes. This information is useful for determining the input matches to the first Filter node, as there is otherwise no way of obtaining the post-intersection matches in an And node, for instance",
          "oneOf": [
            {
              "type": "array",
              "minItems": 2,
              "items": false,
              "prefixItems": [
                { "const": "Some" },
                {
                  "type": "array",
                  "items": { "$ref": "#/definitions/core_match" }
                }
              ]
            },
            { "const": "None" }
          ]
        }
      }
    },
    "matching_operation": {
      "description": "Note that this type is used in Matching_explanation.ml hence the need for deriving show below.",
      "oneOf": [
        { "const": "And" },
        { "const": "Or" },
        { "const": "Inside" },
        { "const": "Anywhere" },
        {
          "type": "array",
          "minItems": 2,
          "items": false,
          "prefixItems": [
            {
              "description": "XPat for eXtended pattern. Can be a spacegrep pattern, a regexp pattern, or a proper semgrep pattern. see semgrep-core/src/core/XPattern.ml",
              "const": "XPat"
            },
            { "type": "string" }
          ]
        },
        { "const": "Negation" },
        {
          "type": "array",
          "minItems": 2,
          "items": false,
          "prefixItems": [ { "const": "Filter" }, { "type": "string" } ]
        },
        { "const": "Taint" },
        { "const": "TaintSource" },
        { "const": "TaintSink" },
        { "const": "TaintSanitizer" },
        { "const": "EllipsisAndStmts" },
        { "const": "ClassHeaderAndElems" }
      ]
    },
    "match_dataflow_trace": {
      "type": "object",
      "required": [],
      "properties": {
        "taint_source": { "$ref": "#/definitions/match_call_trace" },
        "intermediate_vars": {
          "description": "Intermediate variables which are involved in the dataflow. This explains how the taint flows from the source to the sink.",
          "type": "array",
          "items": { "$ref": "#/definitions/match_intermediate_var" }
        },
        "taint_sink": { "$ref": "#/definitions/match_call_trace" }
      }
    },
    "loc_and_content": {
      "description": "The string attached to the location is the actual code from the file. This can contain sensitive information so be careful!\n\nTODO: the type seems redundant since location already specifies a range. maybe this saves some effort to the user of this type which do not need to read the file to get the content.",
      "type": "array",
      "minItems": 2,
      "items": false,
      "prefixItems": [
        { "$ref": "#/definitions/location" }, { "type": "string" }
      ]
    },
    "match_call_trace": {
      "oneOf": [
        {
          "type": "array",
          "minItems": 2,
          "items": false,
          "prefixItems": [
            { "const": "CliLoc" },
            { "$ref": "#/definitions/loc_and_content" }
          ]
        },
        {
          "type": "array",
          "minItems": 2,
          "items": false,
          "prefixItems": [
            { "const": "CliCall" },
            {
              "type": "array",
              "minItems": 3,
              "items": false,
              "prefixItems": [
                { "$ref": "#/definitions/loc_and_content" },
                {
                  "type": "array",
                  "items": { "$ref": "#/definitions/match_intermediate_var" }
                },
                { "$ref": "#/definitions/match_call_trace" }
              ]
            }
          ]
        }
      ]
    },
    "match_intermediate_var": {
      "description": "This type happens to be mostly the same as a loc_and_content for now, but it's split out because Iago has plans to extend this with more information",
      "type": "object",
      "required": [ "location", "content" ],
      "properties": {
        "location": { "$ref": "#/definitions/location" },
        "content": {
          "description": "Unlike abstract_content, this is the actual text read from the corresponding source file",
          "type": "string"
        }
      }
    },
    "ecosystem": {
      "description": "both ecosystem and transitivity below have frozen=True so the generated classes can be hashed and put in sets (see calls to reachable_deps.add() in semgrep SCA code)\n\nalt: type package_manager",
      "oneOf": [
        { "const": "npm" },
        { "const": "pypi" },
        { "const": "gem" },
        { "const": "gomod" },
        { "const": "cargo" },
        { "const": "maven" },
        { "const": "composer" },
        { "const": "nuget" },
        { "const": "pub" },
        { "const": "swiftpm" },
        { "const": "cocoapods" },
        {
          "description": "Deprecated: Mix is a build system, should use Hex, which is the ecosystem",
          "const": "mix"
        },
        { "const": "hex" },
        { "const": "opam" }
      ]
    },
    "dependency_kind": {
      "description": "",
      "oneOf": [
        {
          "description": "we depend directly on the 3rd-party library mentioned in the lockfile (e.g., use of log4j library and concrete calls to log4j in 1st-party code). log4j must be declared as a direct dependency in the manifest file.",
          "const": "direct"
        },
        {
          "description": "we depend indirectly (transitively) on the 3rd-party library (e.g., if we use lodash which itself uses internally log4j then lodash is a Direct dependency and log4j a Transitive one)\n\nalt: Indirect",
          "const": "transitive"
        },
        {
          "description": "If there is insufficient information to determine the transitivity, such as a requirements.txt file without a requirements.in manifest, we leave it Unknown.",
          "const": "unknown"
        }
      ]
    },
    "sca_match": {
      "description": "",
      "type": "object",
      "required": [
        "reachability_rule", "sca_finding_schema", "dependency_match",
        "reachable"
      ],
      "properties": {
        "reachability_rule": {
          "description": "does the rule has a pattern part; otherwise it's a \"parity\" or \"upgrade-only\" rule.",
          "type": "boolean"
        },
        "sca_finding_schema": { "type": "integer" },
        "dependency_match": { "$ref": "#/definitions/dependency_match" },
        "reachable": { "type": "boolean" },
        "kind": {
          "description": "EXPERIMENTAL since 1.108.0",
          "$ref": "#/definitions/sca_match_kind"
        }
      }
    },
    "sca_match_kind": {
      "description": "Note that in addition to \"reachable\" there are also the notions of \"vulnerable\" and \"exploitable\".",
      "oneOf": [
        {
          "type": "array",
          "minItems": 2,
          "items": false,
          "prefixItems": [
            {
              "description": "This is used for \"parity\" or \"upgrade-only\" rules. transitivity indicates whether the match is for a direct or transitive usage of the dependency; for a dependency that is both direct and transitive two findings should be generated.",
              "const": "LockfileOnlyMatch"
            },
            { "$ref": "#/definitions/dependency_kind" }
          ]
        },
        {
          "description": "found the pattern-part of the SCA rule in 1st-party code (reachable as originally defined by Semgrep Inc.) the match location will be in some target code.",
          "const": "DirectReachable"
        },
        {
          "type": "array",
          "minItems": 2,
          "items": false,
          "prefixItems": [
            {
              "description": "found the pattern-part of the SCA rule in third-party code and ultimately found a path from 1st party code to this vulnerable third-party code. The goal of transitive reachability analysis is to change some Undetermined or (LockfileOnlyMatch Transitive) into TransitiveReachable or TransitiveUnreachable",
              "const": "TransitiveReachable"
            },
            { "$ref": "#/definitions/transitive_reachable" }
          ]
        },
        {
          "type": "array",
          "minItems": 2,
          "items": false,
          "prefixItems": [
            {
              "description": "This is a \"positive\" finding in the sense that semgrep was able to prove that the transitive finding is \"safe\" and can be ignored because either there is no call to the pattern-part of the SCA rule in 3rd party code, or if there is it's in third-party code that is not accessed from the 1st-party code (e.g., via callgraph analysis) Note that there is no need for DirectUnreachable because semgrep would never generate such a finding. We have TransitiveUnreachable because semgrep first generates some Undetermined that we then retag as DirectUnreachable.",
              "const": "TransitiveUnreachable"
            },
            { "$ref": "#/definitions/transitive_unreachable" }
          ]
        },
        {
          "type": "array",
          "minItems": 2,
          "items": false,
          "prefixItems": [
            {
              "description": "could not decide because of the engine limitations (e.g., found the use of a vulnerable library in the lockfile but could not find the pattern in first party code and could not access third-party code for further investigation (similar to (LockfileOnlyMatch Transitive))",
              "const": "TransitiveUndetermined"
            },
            { "$ref": "#/definitions/transitive_undetermined" }
          ]
        }
      ]
    },
    "transitive_reachable": {
      "type": "object",
      "required": [ "matches", "callgraph_reachable", "explanation" ],
      "properties": {
        "matches": {
          "description": "The matches we found in 3rd party libraries. Ideally the location in cli_match are relative to the root of the project so one can display matches as package@/path/to/finding.py",
          "type": "array",
          "items": {
            "type": "array",
            "minItems": 2,
            "items": false,
            "prefixItems": [
              { "$ref": "#/definitions/found_dependency" },
              {
                "type": "array",
                "items": { "$ref": "#/definitions/cli_match" }
              }
            ]
          }
        },
        "callgraph_reachable": {
          "description": "LATER: add callgraph information so one can see the path from 1st party code to the vulnerable intermediate 3rd party function. This is set to None for now.",
          "oneOf": [
            {
              "type": "array",
              "minItems": 2,
              "items": false,
              "prefixItems": [ { "const": "Some" }, { "type": "boolean" } ]
            },
            { "const": "None" }
          ]
        },
        "explanation": {
          "description": "some extra explanation that the user can understand",
          "oneOf": [
            {
              "type": "array",
              "minItems": 2,
              "items": false,
              "prefixItems": [ { "const": "Some" }, { "type": "string" } ]
            },
            { "const": "None" }
          ]
        }
      }
    },
    "transitive_unreachable": {
      "type": "object",
      "required": [ "analyzed_packages", "explanation" ],
      "properties": {
        "analyzed_packages": {
          "description": "We didn't find any findings in all the 3rd party libraries that are using the 3rd party vulnerable library. This is a \"proof of work\".",
          "type": "array",
          "items": { "$ref": "#/definitions/found_dependency" }
        },
        "explanation": {
          "description": "some extra explanation that the user can understand",
          "oneOf": [
            {
              "type": "array",
              "minItems": 2,
              "items": false,
              "prefixItems": [ { "const": "Some" }, { "type": "string" } ]
            },
            { "const": "None" }
          ]
        }
      }
    },
    "transitive_undetermined": {
      "type": "object",
      "required": [ "explanation" ],
      "properties": {
        "explanation": {
          "oneOf": [
            {
              "type": "array",
              "minItems": 2,
              "items": false,
              "prefixItems": [ { "const": "Some" }, { "type": "string" } ]
            },
            { "const": "None" }
          ]
        }
      }
    },
    "dependency_match": {
      "type": "object",
      "required": [ "dependency_pattern", "found_dependency", "lockfile" ],
      "properties": {
        "dependency_pattern": { "$ref": "#/definitions/sca_pattern" },
        "found_dependency": { "$ref": "#/definitions/found_dependency" },
        "lockfile": { "$ref": "#/definitions/fpath" }
      }
    },
    "sca_pattern": {
      "type": "object",
      "required": [ "ecosystem", "package", "semver_range" ],
      "properties": {
        "ecosystem": { "$ref": "#/definitions/ecosystem" },
        "package": { "type": "string" },
        "semver_range": { "type": "string" }
      }
    },
    "found_dependency": {
      "type": "object",
      "required": [
        "package", "version", "ecosystem", "allowed_hashes", "transitivity"
      ],
      "properties": {
        "package": { "type": "string" },
        "version": { "type": "string" },
        "ecosystem": { "$ref": "#/definitions/ecosystem" },
        "allowed_hashes": {
          "description": "???",
          "type": "object",
          "additionalProperties": {
            "type": "array",
            "items": { "type": "string" }
          }
        },
        "resolved_url": { "type": "string" },
        "transitivity": { "$ref": "#/definitions/dependency_kind" },
        "manifest_path": {
          "description": "Path to the manifest file that defines the project containing this dependency. Examples: package.json, nested/folder/pom.xml",
          "$ref": "#/definitions/fpath"
        },
        "lockfile_path": {
          "description": "Path to the lockfile that contains this dependency. Examples: package-lock.json, nested/folder/requirements.txt, go.mod. Since 1.87.0",
          "$ref": "#/definitions/fpath"
        },
        "line_number": {
          "description": "The line number of the dependency in the lockfile. When combined with the lockfile_path, this can identify the location of the dependency in the lockfile.",
          "type": "integer"
        },
        "children": {
          "description": "If we have dependency relationship information for this dependency, this field will include the name and version of other found_dependency items that this dependency requires. These fields must match values in `package` and `version` of another `found_dependency` in the same set",
          "type": "array",
          "items": { "$ref": "#/definitions/dependency_child" }
        },
        "git_ref": {
          "description": "Git ref of the dependency if the dependency comes directly from a git repo. Examples: refs/heads/main, refs/tags/v1.0.0, e5c704df4d308690fed696faf4c86453b4d88a95. Since 1.66.0",
          "type": "string"
        }
      }
    },
    "dependency_child": {
      "type": "object",
      "required": [ "package", "version" ],
      "properties": {
        "package": { "type": "string" },
        "version": { "type": "string" }
      }
    },
    "validation_state": {
      "description": "This type is used by postprocessors for secrets to report back the validity of a finding. No_validator is currently also used when no validation has yet occurred, which if that becomes confusing we could adjust that, by adding another state.",
      "oneOf": [
        { "const": "CONFIRMED_VALID" },
        { "const": "CONFIRMED_INVALID" },
        { "const": "VALIDATION_ERROR" },
        { "const": "NO_VALIDATOR" }
      ]
    },
    "historical_info": {
      "description": "part of cli_match_extra",
      "type": "object",
      "required": [ "git_commit", "git_commit_timestamp" ],
      "properties": {
        "git_commit": {
          "description": "Git commit at which the finding is present. Used by \"historical\" scans, which scan non-HEAD commits in the git history. Relevant for finding, e.g., secrets which are buried in the git history which we wouldn't find at HEAD",
          "$ref": "#/definitions/sha1"
        },
        "git_blob": {
          "description": "Git blob at which the finding is present. Sent in addition to the commit since some SCMs have permalinks which use the blob sha, so this information is useful when generating links back to the SCM.",
          "$ref": "#/definitions/sha1"
        },
        "git_commit_timestamp": { "$ref": "#/definitions/datetime" }
      }
    },
    "error_type": {
      "oneOf": [
        {
          "description": "File parsing related errors; coupling: if you add a target parse error then metrics for cli need to be updated. See cli/src/semgrep/parsing_data.py.",
          "const": "Lexical error"
        },
        { "description": "a.k.a SyntaxError", "const": "Syntax error" },
        { "const": "Other syntax error" },
        { "const": "AST builder error" },
        {
          "description": "Pattern parsing related errors. There are more precise info about the error in Rule.invalid_rule_error_kind in Rule.ml.",
          "const": "Rule parse error"
        },
        {
          "description": "generated in pysemgrep only",
          "const": "SemgrepWarning"
        },
        { "const": "SemgrepError" },
        { "const": "InvalidRuleSchemaError" },
        { "const": "UnknownLanguageError" },
        { "const": "Invalid YAML" },
        {
          "description": "internal error, e.g., NoTokenLocation",
          "const": "Internal matching error"
        },
        { "const": "Semgrep match found" },
        { "const": "Too many matches" },
        {
          "description": "missing file, OCaml errors, etc.",
          "const": "Fatal error"
        },
        { "const": "Timeout" },
        { "const": "Out of memory" },
        {
          "description": "since semgrep 1.132.0",
          "const": "Fixpoint timeout"
        },
        { "description": "since semgrep 1.86.0", "const": "Stack overflow" },
        { "const": "Timeout during interfile analysis" },
        { "const": "OOM during interfile analysis" },
        { "description": "since semgrep 1.40.0", "const": "Missing plugin" },
        {
          "type": "array",
          "minItems": 2,
          "items": false,
          "prefixItems": [
            {
              "description": "the string list is the \"YAML path\" of the pattern, e.g. {{[\"rules\"; \"1\"; ...]}}",
              "const": "PatternParseError"
            },
            { "type": "array", "items": { "type": "string" } }
          ]
        },
        {
          "type": "array",
          "minItems": 2,
          "items": false,
          "prefixItems": [
            {
              "description": "list of skipped tokens. Since semgrep 0.97.",
              "const": "PartialParsing"
            },
            {
              "type": "array",
              "items": { "$ref": "#/definitions/location" }
            }
          ]
        },
        {
          "type": "array",
          "minItems": 2,
          "items": false,
          "prefixItems": [
            {
              "description": "since semgrep 1.38.0",
              "const": "IncompatibleRule"
            },
            { "$ref": "#/definitions/incompatible_rule" }
          ]
        },
        {
          "description": "Those Xxx0 variants were introduced in semgrep 1.45.0, but actually they are here so that our backend can read the cli_error.type_ from old semgrep versions that were translating the PatternParseError _ and IncompatibleRule _ above as a single string (instead of a list [\"PatternParseError\", ...] now). There is no PartialParsing0 because this was encoded as a ParseError instead.",
          "const": "Pattern parse error"
        },
        { "const": "Incompatible rule" },
        {
          "type": "array",
          "minItems": 2,
          "items": false,
          "prefixItems": [
            {
              "description": "since semgrep 1.94.0",
              "const": "DependencyResolutionError"
            },
            { "$ref": "#/definitions/resolution_error_kind" }
          ]
        }
      ]
    },
    "incompatible_rule": {
      "type": "object",
      "required": [ "rule_id", "this_version" ],
      "properties": {
        "rule_id": { "$ref": "#/definitions/rule_id" },
        "this_version": { "$ref": "#/definitions/version" },
        "min_version": { "$ref": "#/definitions/version" },
        "max_version": { "$ref": "#/definitions/version" }
      }
    },
    "cli_error": {
      "description": "(called SemgrepError in error.py)",
      "type": "object",
      "required": [ "code", "level", "type" ],
      "properties": {
        "code": {
          "description": "exit code for the type_ of error",
          "type": "integer"
        },
        "level": { "$ref": "#/definitions/error_severity" },
        "type": {
          "description": "before 1.45.0 the type below was 'string', but was the result of converting error_type into a string, so using directly 'error_type' below should be mostly backward compatible thx to the <json name> annotations in error_type. To be fully backward compatible, we actually introduced the PatternParseError0 and IncompatibleRule0 cases in error_type.",
          "$ref": "#/definitions/error_type"
        },
        "rule_id": { "$ref": "#/definitions/rule_id" },
        "message": {
          "description": "contains error location",
          "type": "string"
        },
        "path": { "$ref": "#/definitions/fpath" },
        "long_msg": {
          "description": "for invalid rules, for ErrorWithSpan",
          "type": "string"
        },
        "short_msg": { "type": "string" },
        "spans": {
          "type": "array",
          "items": { "$ref": "#/definitions/error_span" }
        },
        "help": { "type": "string" }
      }
    },
    "error_span": {
      "type": "object",
      "required": [ "file", "start", "end" ],
      "properties": {
        "file": {
          "description": "for InvalidRuleSchemaError",
          "$ref": "#/definitions/fpath"
        },
        "start": { "$ref": "#/definitions/position" },
        "end": { "$ref": "#/definitions/position" },
        "source_hash": { "type": "string" },
        "config_start": {
          "description": "The path to the pattern in the yaml rule and an adjusted start/end within just the pattern. Used to report playground parse errors in the simple editor",
          "$ref": "#/definitions/position"
        },
        "config_end": { "$ref": "#/definitions/position" },
        "config_path": {
          "type": [ "array", "null" ],
          "items": { "type": "string" }
        },
        "context_start": {
          "description": "",
          "$ref": "#/definitions/position"
        },
        "context_end": { "$ref": "#/definitions/position" }
      }
    },
    "skip_reason": {
      "description": "A reason for skipping a target file or a pair (target, rule). Note that this type is also used in Report.ml hence the need for deriving show here.\n\nFor consistency, please make sure all the JSON constructors use the same case rules (lowercase, underscores). This is hard to fix later! Please review your code carefully before committing to interface changes.",
      "oneOf": [
        { "const": "always_skipped" },
        { "const": "semgrepignore_patterns_match" },
        { "const": "cli_include_flags_do_not_match" },
        { "const": "cli_exclude_flags_match" },
        { "const": "exceeded_size_limit" },
        { "const": "analysis_failed_parser_or_internal_error" },
        { "const": "excluded_by_config" },
        { "const": "wrong_language" },
        { "const": "too_big" },
        { "const": "minified" },
        { "const": "binary" },
        { "const": "irrelevant_rule" },
        { "const": "too_many_matches" },
        { "const": "Gitignore_patterns_match" },
        {
          "description": "since 1.40.0. They were always ignored, but not shown in the skip report",
          "const": "Dotfile"
        },
        { "description": "since 1.44.0", "const": "Nonexistent_file" },
        {
          "description": "since 1.94.0",
          "const": "insufficient_permissions"
        }
      ]
    },
    "skipped_target": {
      "description": "coupling: ugly: with yield_json_objects() in target_manager.py",
      "type": "object",
      "required": [ "path", "reason" ],
      "properties": {
        "path": { "$ref": "#/definitions/fpath" },
        "reason": { "$ref": "#/definitions/skip_reason" },
        "details": {
          "description": "since semgrep 1.39.0 (used to be return only by semgrep-core)",
          "type": "string"
        },
        "rule_id": {
          "description": "If the 'rule_id' field is missing, the target is assumed to have been skipped for all the rules",
          "$ref": "#/definitions/rule_id"
        }
      }
    },
    "scanned_and_skipped": {
      "type": "object",
      "required": [ "scanned" ],
      "properties": {
        "scanned": {
          "type": "array",
          "items": { "$ref": "#/definitions/fpath" }
        },
        "skipped": {
          "type": "array",
          "items": { "$ref": "#/definitions/skipped_target" }
        }
      }
    },
    "skipped_rule": {
      "type": "object",
      "required": [ "rule_id", "details", "position" ],
      "properties": {
        "rule_id": { "$ref": "#/definitions/rule_id" },
        "details": { "type": "string" },
        "position": {
          "description": "position of the error in the rule file",
          "$ref": "#/definitions/position"
        }
      }
    },
    "target_discovery_result": {
      "description": "Result of get_targets internal RPC, similar to scanned_and_skipped but more complete",
      "type": "object",
      "required": [ "target_paths", "errors", "skipped" ],
      "properties": {
        "target_paths": {
          "type": "array",
          "items": { "$ref": "#/definitions/fppath" }
        },
        "errors": {
          "type": "array",
          "items": { "$ref": "#/definitions/core_error" }
        },
        "skipped": {
          "type": "array",
          "items": { "$ref": "#/definitions/skipped_target" }
        }
      }
    },
    "profile": {
      "description": "Run locally $ ./run-benchmarks --dummy --upload",
      "type": "object",
      "required": [
        "rules", "rules_parse_time", "profiling_times", "targets",
        "total_bytes"
      ],
      "properties": {
        "rules": {
          "description": "List of rules, including the one read but not run on any target. This list is actually more an array which allows other fields to reference rule by number instead of rule_id (e.g., match_times further below) saving space in the JSON.\n\nUpgrade note: this used to be defined as a rule_id_dict where each rule_id was inside a {id: rule_id; ...} record so we could give parsing time info about each rule, but parsing one rule was never the slow part, so now we just juse the aggregated rules_parse_time below and do not need a complex rule_id_dict record anymore.",
          "type": "array",
          "items": { "$ref": "#/definitions/rule_id" }
        },
        "rules_parse_time": { "type": "number" },
        "profiling_times": {
          "type": "object",
          "additionalProperties": { "type": "number" }
        },
        "parsing_time": {
          "description": "EXPERIMENTAL",
          "$ref": "#/definitions/parsing_time"
        },
        "scanning_time": {
          "description": "EXPERIMENTAL",
          "$ref": "#/definitions/scanning_time"
        },
        "matching_time": {
          "description": "EXPERIMENTAL",
          "$ref": "#/definitions/matching_time"
        },
        "tainting_time": {
          "description": "EXPERIMENTAL",
          "$ref": "#/definitions/tainting_time"
        },
        "fixpoint_timeouts": {
          "description": "EXPERIMENTAL: Dafatlow fixpoint-function timeouts\n\nHappen more often than we would like, and it's mainly Semgrep devs that will use this info for debugging, so for now we are reporting these timeouts as part of the profiling report.",
          "type": "array",
          "items": { "$ref": "#/definitions/core_error" }
        },
        "prefiltering": { "$ref": "#/definitions/prefiltering_stats" },
        "targets": {
          "type": "array",
          "items": { "$ref": "#/definitions/target_times" }
        },
        "total_bytes": { "type": "integer" },
        "max_memory_bytes": {
          "description": "maximum amount of memory used by Semgrep(-core) during its execution",
          "type": "integer"
        }
      }
    },
    "file_time": {
      "description": "EXPERIMENTAL",
      "type": "object",
      "required": [ "fpath", "ftime" ],
      "properties": {
        "fpath": { "$ref": "#/definitions/fpath" },
        "ftime": { "type": "number" }
      }
    },
    "file_rule_time": {
      "description": "EXPERIMENTAL",
      "type": "object",
      "required": [ "fpath", "rule_id", "time" ],
      "properties": {
        "fpath": { "$ref": "#/definitions/fpath" },
        "rule_id": { "$ref": "#/definitions/rule_id" },
        "time": { "type": "number" }
      }
    },
    "def_rule_time": {
      "description": "EXPERIMENTAL",
      "type": "object",
      "required": [ "fpath", "fline", "rule_id", "time" ],
      "properties": {
        "fpath": { "$ref": "#/definitions/fpath" },
        "fline": { "type": "integer" },
        "rule_id": { "$ref": "#/definitions/rule_id" },
        "time": { "type": "number" }
      }
    },
    "summary_stats": {
      "description": "EXPERIMENTAL",
      "type": "object",
      "required": [ "mean", "std_dev" ],
      "properties": {
        "mean": { "type": "number" },
        "std_dev": { "type": "number" }
      }
    },
    "very_slow_stats": {
      "description": "These ratios are numbers in [0, 1], and we would hope that both 'time_ratio' and 'count_ratio' are very close to 0. In bad cases, we may see the 'count_ratio' being close to 0 while the 'time_ratio' is above 0.5, meaning that a small number of very slow files/etc represent a large amount of the total processing time. EXPERIMENTAL",
      "type": "object",
      "required": [ "time_ratio", "count_ratio" ],
      "properties": {
        "time_ratio": { "description": "", "type": "number" },
        "count_ratio": { "description": "", "type": "number" }
      }
    },
    "parsing_time": {
      "description": "EXPERIMENTAL",
      "type": "object",
      "required": [ "total_time", "per_file_time", "very_slow_files" ],
      "properties": {
        "total_time": { "type": "number" },
        "per_file_time": { "$ref": "#/definitions/summary_stats" },
        "very_slow_stats": { "$ref": "#/definitions/very_slow_stats" },
        "very_slow_files": {
          "description": "ascending order",
          "type": "array",
          "items": { "$ref": "#/definitions/file_time" }
        }
      }
    },
    "scanning_time": {
      "description": "Scanning time (includes matching and tainting) EXPERIMENTAL",
      "type": "object",
      "required": [
        "total_time", "per_file_time", "very_slow_stats", "very_slow_files"
      ],
      "properties": {
        "total_time": { "type": "number" },
        "per_file_time": { "$ref": "#/definitions/summary_stats" },
        "very_slow_stats": { "$ref": "#/definitions/very_slow_stats" },
        "very_slow_files": {
          "description": "ascending order",
          "type": "array",
          "items": { "$ref": "#/definitions/file_time" }
        }
      }
    },
    "matching_time": {
      "description": "",
      "type": "object",
      "required": [
        "total_time", "per_file_and_rule_time", "very_slow_stats",
        "very_slow_rules_on_files"
      ],
      "properties": {
        "total_time": { "type": "number" },
        "per_file_and_rule_time": { "$ref": "#/definitions/summary_stats" },
        "very_slow_stats": { "$ref": "#/definitions/very_slow_stats" },
        "very_slow_rules_on_files": {
          "description": "",
          "type": "array",
          "items": { "$ref": "#/definitions/file_rule_time" }
        }
      }
    },
    "tainting_time": {
      "description": "",
      "type": "object",
      "required": [
        "total_time", "per_def_and_rule_time", "very_slow_stats",
        "very_slow_rules_on_defs"
      ],
      "properties": {
        "total_time": { "type": "number" },
        "per_def_and_rule_time": { "$ref": "#/definitions/summary_stats" },
        "very_slow_stats": { "$ref": "#/definitions/very_slow_stats" },
        "very_slow_rules_on_defs": {
          "description": "",
          "type": "array",
          "items": { "$ref": "#/definitions/def_rule_time" }
        }
      }
    },
    "target_times": {
      "type": "object",
      "required": [
        "path", "num_bytes", "match_times", "parse_times", "run_time"
      ],
      "properties": {
        "path": { "$ref": "#/definitions/fpath" },
        "num_bytes": { "type": "integer" },
        "match_times": {
          "description": "",
          "type": "array",
          "items": { "type": "number" }
        },
        "parse_times": {
          "description": "",
          "type": "array",
          "items": { "type": "number" }
        },
        "run_time": { "description": "", "type": "number" }
      }
    },
    "prefiltering_stats": {
      "type": "object",
      "required": [
        "project_level_time", "file_level_time",
        "rules_with_project_prefilters_ratio",
        "rules_with_file_prefilters_ratio", "rules_selected_ratio",
        "rules_matched_ratio"
      ],
      "properties": {
        "project_level_time": { "description": "", "type": "number" },
        "file_level_time": { "description": "", "type": "number" },
        "rules_with_project_prefilters_ratio": {
          "description": "",
          "type": "number"
        },
        "rules_with_file_prefilters_ratio": {
          "description": "",
          "type": "number"
        },
        "rules_selected_ratio": { "description": "", "type": "number" },
        "rules_matched_ratio": { "description": "", "type": "number" }
      }
    },
    "mcp_scan_results": {
      "type": "object",
      "required": [ "rules", "total_bytes_scanned" ],
      "properties": {
        "rules": { "type": "array", "items": { "type": "string" } },
        "total_bytes_scanned": { "type": "integer" }
      }
    },
    "cli_output_extra": {
      "type": "object",
      "required": [ "paths" ],
      "properties": {
        "paths": {
          "description": "",
          "$ref": "#/definitions/scanned_and_skipped"
        },
        "time": { "description": "", "$ref": "#/definitions/profile" },
        "explanations": {
          "description": "",
          "type": "array",
          "items": { "$ref": "#/definitions/matching_explanation" }
        },
        "rules_by_engine": {
          "description": "",
          "type": "array",
          "items": { "$ref": "#/definitions/rule_id_and_engine_kind" }
        },
        "engine_requested": { "$ref": "#/definitions/engine_kind" },
        "interfile_languages_used": {
          "description": "",
          "type": "array",
          "items": { "type": "string" }
        },
        "skipped_rules": {
          "description": "",
          "type": "array",
          "items": { "$ref": "#/definitions/skipped_rule" }
        },
        "subprojects": {
          "description": "",
          "type": "array",
          "items": { "$ref": "#/definitions/cli_output_subproject_info" }
        },
        "mcp_scan_results": {
          "description": "",
          "$ref": "#/definitions/mcp_scan_results"
        },
        "profiling_results": {
          "description": "",
          "type": "array",
          "items": { "$ref": "#/definitions/profiling_entry" }
        }
      }
    },
    "config_error_reason": { "oneOf": [ { "const": "unparsable_rule" } ] },
    "config_error": {
      "type": "object",
      "required": [ "file", "reason" ],
      "properties": {
        "file": { "$ref": "#/definitions/fpath" },
        "reason": { "$ref": "#/definitions/config_error_reason" }
      }
    },
    "tests_result": {
      "type": "object",
      "required": [
        "results", "fixtest_results", "config_missing_tests",
        "config_missing_fixtests", "config_with_errors"
      ],
      "properties": {
        "results": {
          "description": "",
          "type": "object",
          "additionalProperties": { "$ref": "#/definitions/checks" }
        },
        "fixtest_results": {
          "description": "",
          "type": "object",
          "additionalProperties": { "$ref": "#/definitions/fixtest_result" }
        },
        "config_missing_tests": {
          "type": "array",
          "items": { "$ref": "#/definitions/fpath" }
        },
        "config_missing_fixtests": {
          "type": "array",
          "items": { "$ref": "#/definitions/fpath" }
        },
        "config_with_errors": {
          "type": "array",
          "items": { "$ref": "#/definitions/config_error" }
        }
      }
    },
    "checks": {
      "type": "object",
      "required": [ "checks" ],
      "properties": {
        "checks": {
          "description": "",
          "type": "object",
          "additionalProperties": { "$ref": "#/definitions/rule_result" }
        }
      }
    },
    "rule_result": {
      "type": "object",
      "required": [ "passed", "matches", "errors" ],
      "properties": {
        "passed": { "type": "boolean" },
        "matches": {
          "description": "",
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/expected_reported"
          }
        },
        "errors": {
          "type": "array",
          "items": { "$ref": "#/definitions/todo" }
        },
        "diagnosis": {
          "description": "",
          "$ref": "#/definitions/matching_diagnosis"
        }
      }
    },
    "expected_reported": {
      "type": "object",
      "required": [ "expected_lines", "reported_lines" ],
      "properties": {
        "expected_lines": { "type": "array", "items": { "type": "integer" } },
        "reported_lines": { "type": "array", "items": { "type": "integer" } }
      }
    },
    "fixtest_result": {
      "type": "object",
      "required": [ "passed" ],
      "properties": { "passed": { "type": "boolean" } }
    },
    "todo": { "type": "integer" },
    "matching_diagnosis": {
      "type": "object",
      "required": [
        "target", "unexpected_match_diagnoses",
        "unexpected_no_match_diagnoses"
      ],
      "properties": {
        "target": { "description": "", "$ref": "#/definitions/fpath" },
        "unexpected_match_diagnoses": {
          "type": "array",
          "items": { "$ref": "#/definitions/unexpected_match_diagnosis" }
        },
        "unexpected_no_match_diagnoses": {
          "type": "array",
          "items": { "$ref": "#/definitions/unexpected_no_match_diagnosis" }
        }
      }
    },
    "unexpected_match_diagnosis": {
      "type": "object",
      "required": [
        "matched_text", "originating_kind", "originating_text",
        "killing_parents"
      ],
      "properties": {
        "matched_text": { "$ref": "#/definitions/snippet" },
        "originating_kind": {
          "description": "",
          "$ref": "#/definitions/originating_node_kind"
        },
        "originating_text": { "$ref": "#/definitions/snippet" },
        "killing_parents": {
          "type": "array",
          "items": { "$ref": "#/definitions/killing_parent" }
        }
      }
    },
    "unexpected_no_match_diagnosis": {
      "type": "object",
      "required": [ "line", "kind" ],
      "properties": {
        "line": { "type": "integer" },
        "kind": {
          "$ref": "#/definitions/unexpected_no_match_diagnosis_kind"
        }
      }
    },
    "unexpected_no_match_diagnosis_kind": {
      "oneOf": [
        { "const": "Never_matched" },
        {
          "type": "array",
          "minItems": 2,
          "items": false,
          "prefixItems": [
            { "const": "Killed_by_nodes" },
            {
              "type": "array",
              "items": { "$ref": "#/definitions/killing_parent" }
            }
          ]
        }
      ]
    },
    "originating_node_kind": {
      "oneOf": [ { "const": "Focus" }, { "const": "Xpattern" } ]
    },
    "killing_parent_kind": {
      "oneOf": [
        { "const": "And" },
        { "const": "Inside" },
        { "const": "Negation" },
        {
          "type": "array",
          "minItems": 2,
          "items": false,
          "prefixItems": [ { "const": "Filter" }, { "type": "string" } ]
        }
      ]
    },
    "snippet": {
      "description": "",
      "type": "object",
      "required": [ "line", "text" ],
      "properties": {
        "line": { "type": "integer" },
        "text": { "type": "string" }
      }
    },
    "killing_parent": {
      "description": "",
      "type": "object",
      "required": [ "killing_parent_kind", "snippet" ],
      "properties": {
        "killing_parent_kind": {
          "$ref": "#/definitions/killing_parent_kind"
        },
        "snippet": { "$ref": "#/definitions/snippet" }
      }
    },
    "features": {
      "type": "object",
      "required": [],
      "properties": {
        "autofix": { "type": "boolean" },
        "deepsemgrep": { "type": "boolean" },
        "dependency_query": { "type": "boolean" },
        "path_to_transitivity": { "description": "", "type": "boolean" },
        "scan_all_deps_in_diff_scan": {
          "description": "",
          "type": "boolean"
        },
        "symbol_analysis": { "description": "", "type": "boolean" },
        "transitive_reachability_enabled": { "type": "boolean" }
      }
    },
    "triage_ignored": {
      "type": "object",
      "required": [],
      "properties": {
        "triage_ignored_syntactic_ids": {
          "type": "array",
          "items": { "type": "string" }
        },
        "triage_ignored_match_based_ids": {
          "description": "",
          "type": "array",
          "items": { "type": "string" }
        }
      }
    },
    "action": {
      "oneOf": [
        {
          "type": "array",
          "minItems": 2,
          "items": false,
          "prefixItems": [ { "const": "Message" }, { "type": "string" } ]
        },
        {
          "type": "array",
          "minItems": 2,
          "items": false,
          "prefixItems": [
            { "description": "", "const": "Delay" }, { "type": "number" }
          ]
        },
        {
          "type": "array",
          "minItems": 2,
          "items": false,
          "prefixItems": [
            { "description": "", "const": "Exit" }, { "type": "integer" }
          ]
        }
      ]
    },
    "scan_response": {
      "description": "",
      "type": "object",
      "required": [ "info", "config", "engine_params" ],
      "properties": {
        "info": { "$ref": "#/definitions/scan_info" },
        "config": { "$ref": "#/definitions/scan_configuration" },
        "engine_params": { "$ref": "#/definitions/engine_configuration" }
      }
    },
    "scan_info": {
      "type": "object",
      "required": [ "enabled_products", "deployment_id", "deployment_name" ],
      "properties": {
        "id": { "description": "", "type": "integer" },
        "enabled_products": {
          "type": "array",
          "items": { "$ref": "#/definitions/product" }
        },
        "deployment_id": { "type": "integer" },
        "deployment_name": { "type": "string" }
      }
    },
    "scan_configuration": {
      "description": "",
      "type": "object",
      "required": [ "rules" ],
      "properties": {
        "rules": { "$ref": "#/definitions/raw_json" },
        "triage_ignored_syntactic_ids": {
          "type": "array",
          "items": { "type": "string" }
        },
        "triage_ignored_match_based_ids": {
          "description": "",
          "type": "array",
          "items": { "type": "string" }
        },
        "project_merge_base": {
          "description": "",
          "$ref": "#/definitions/sha1"
        },
        "fips_mode": { "description": "", "type": "boolean" }
      }
    },
    "engine_configuration": {
      "type": "object",
      "required": [],
      "properties": {
        "autofix": { "type": "boolean" },
        "deepsemgrep": { "type": "boolean" },
        "dependency_query": { "type": "boolean" },
        "path_to_transitivity": { "description": "", "type": "boolean" },
        "scan_all_deps_in_diff_scan": {
          "description": "",
          "type": "boolean"
        },
        "symbol_analysis": { "description": "", "type": "boolean" },
        "transitive_reachability_enabled": { "type": "boolean" },
        "ignored_files": {
          "description": "",
          "type": "array",
          "items": { "type": "string" }
        },
        "product_ignored_files": {
          "description": "",
          "$ref": "#/definitions/product_ignored_files"
        },
        "generic_slow_rollout": { "description": "", "type": "boolean" },
        "historical_config": {
          "description": "",
          "$ref": "#/definitions/historical_configuration"
        },
        "always_suppress_errors": { "description": "", "type": "boolean" }
      }
    },
    "product_ignored_files": {
      "description": "",
      "type": "array",
      "items": {
        "type": "array",
        "minItems": 2,
        "items": false,
        "prefixItems": [
          { "$ref": "#/definitions/product" },
          { "type": "array", "items": { "$ref": "#/definitions/glob" } }
        ]
      }
    },
    "historical_configuration": {
      "description": "",
      "type": "object",
      "required": [ "enabled" ],
      "properties": {
        "enabled": { "type": "boolean" },
        "lookback_days": { "type": "integer" }
      }
    },
    "scan_request": {
      "description": "",
      "type": "object",
      "required": [ "project_metadata", "scan_metadata" ],
      "properties": {
        "project_metadata": { "$ref": "#/definitions/project_metadata" },
        "scan_metadata": { "$ref": "#/definitions/scan_metadata" },
        "project_config": { "$ref": "#/definitions/ci_config_from_repo" }
      }
    },
    "project_metadata": {
      "description": "",
      "type": "object",
      "required": [
        "scan_environment", "repository", "repo_url", "branch", "commit",
        "commit_title", "commit_author_email", "commit_author_name",
        "commit_author_username", "commit_author_image_url", "ci_job_url",
        "on", "pull_request_author_username",
        "pull_request_author_image_url", "pull_request_id",
        "pull_request_title", "is_full_scan"
      ],
      "properties": {
        "scan_environment": { "description": "", "type": "string" },
        "repository": { "description": "", "type": "string" },
        "repo_url": { "$ref": "#/definitions/uri" },
        "repo_id": { "description": "", "type": "string" },
        "org_id": { "description": "", "type": "string" },
        "repo_display_name": { "description": "", "type": "string" },
        "branch": { "description": "", "type": [ "string", "null" ] },
        "commit": { "$ref": "#/definitions/sha1" },
        "commit_title": { "type": [ "string", "null" ] },
        "commit_timestamp": {
          "description": "",
          "$ref": "#/definitions/datetime"
        },
        "commit_author_email": { "type": [ "string", "null" ] },
        "commit_author_name": { "type": [ "string", "null" ] },
        "commit_author_username": { "type": [ "string", "null" ] },
        "commit_author_image_url": { "$ref": "#/definitions/uri" },
        "ci_job_url": { "$ref": "#/definitions/uri" },
        "on": { "description": "", "type": "string" },
        "pull_request_author_username": { "type": [ "string", "null" ] },
        "pull_request_author_image_url": { "$ref": "#/definitions/uri" },
        "pull_request_id": { "type": [ "string", "null" ] },
        "pull_request_title": { "type": [ "string", "null" ] },
        "base_branch_head_commit": {
          "description": "",
          "$ref": "#/definitions/sha1"
        },
        "base_sha": { "description": "", "$ref": "#/definitions/sha1" },
        "start_sha": { "description": "", "$ref": "#/definitions/sha1" },
        "is_full_scan": { "description": "", "type": "boolean" },
        "is_sca_scan": { "description": "", "type": "boolean" },
        "is_code_scan": { "description": "", "type": "boolean" },
        "is_secrets_scan": { "description": "", "type": "boolean" },
        "project_id": { "description": "", "type": "string" }
      }
    },
    "scan_metadata": {
      "description": "",
      "type": "object",
      "required": [ "cli_version", "unique_id", "requested_products" ],
      "properties": {
        "cli_version": { "$ref": "#/definitions/version" },
        "unique_id": { "description": "", "$ref": "#/definitions/uuid" },
        "requested_products": {
          "type": "array",
          "items": { "$ref": "#/definitions/product" }
        },
        "dry_run": { "description": "", "type": "boolean" },
        "sms_scan_id": { "description": "", "type": "string" },
        "ecosystems": { "type": "array", "items": { "type": "string" } },
        "packages": { "type": "array", "items": { "type": "string" } }
      }
    },
    "ci_config_from_repo": {
      "type": "object",
      "required": [],
      "properties": {
        "version": { "description": "", "$ref": "#/definitions/version" },
        "tags": { "type": "array", "items": { "$ref": "#/definitions/tag" } }
      }
    },
    "tag": { "description": "", "type": "string" },
    "finding": {
      "type": "object",
      "required": [
        "check_id", "path", "line", "column", "end_line", "end_column",
        "message", "severity", "index", "commit_date", "syntactic_id",
        "metadata", "is_blocking"
      ],
      "properties": {
        "check_id": { "$ref": "#/definitions/rule_id" },
        "path": { "$ref": "#/definitions/fpath" },
        "line": { "type": "integer" },
        "column": { "type": "integer" },
        "end_line": { "type": "integer" },
        "end_column": { "type": "integer" },
        "message": { "type": "string" },
        "severity": { "description": "" },
        "index": { "type": "integer" },
        "commit_date": { "type": "string" },
        "syntactic_id": { "type": "string" },
        "match_based_id": { "description": "", "type": "string" },
        "hashes": {
          "description": "",
          "$ref": "#/definitions/finding_hashes"
        },
        "metadata": { "description": "", "$ref": "#/definitions/raw_json" },
        "is_blocking": { "type": "boolean" },
        "fixed_lines": { "type": "array", "items": { "type": "string" } },
        "sca_info": { "$ref": "#/definitions/sca_match" },
        "dataflow_trace": {
          "description": "",
          "$ref": "#/definitions/match_dataflow_trace"
        },
        "validation_state": {
          "description": "",
          "$ref": "#/definitions/validation_state"
        },
        "historical_info": {
          "description": "",
          "$ref": "#/definitions/historical_info"
        },
        "engine_kind": {
          "description": "",
          "$ref": "#/definitions/engine_of_finding"
        }
      }
    },
    "finding_hashes": {
      "type": "object",
      "required": [
        "start_line_hash", "end_line_hash", "code_hash", "pattern_hash"
      ],
      "properties": {
        "start_line_hash": { "type": "string" },
        "end_line_hash": { "type": "string" },
        "code_hash": { "description": "", "type": "string" },
        "pattern_hash": { "description": "", "type": "string" }
      }
    },
    "ci_scan_results": {
      "type": "object",
      "required": [
        "findings", "ignores", "token", "searched_paths", "renamed_paths",
        "rule_ids"
      ],
      "properties": {
        "findings": {
          "type": "array",
          "items": { "$ref": "#/definitions/finding" }
        },
        "ignores": {
          "type": "array",
          "items": { "$ref": "#/definitions/finding" }
        },
        "token": { "type": [ "string", "null" ] },
        "searched_paths": {
          "type": "array",
          "items": { "$ref": "#/definitions/fpath" }
        },
        "renamed_paths": {
          "type": "array",
          "items": { "$ref": "#/definitions/fpath" }
        },
        "rule_ids": {
          "type": "array",
          "items": { "$ref": "#/definitions/rule_id" }
        },
        "contributions": {
          "description": "",
          "$ref": "#/definitions/contributions"
        },
        "dependencies": {
          "description": "",
          "$ref": "#/definitions/ci_scan_dependencies"
        },
        "metadata": {
          "description": "",
          "$ref": "#/definitions/ci_scan_metadata"
        }
      }
    },
    "ci_scan_metadata": {
      "description": "",
      "type": "object",
      "required": [
        "scan_id", "deployment_id", "repository_id", "repository_ref_id",
        "enabled_products", "git_commit", "git_ref"
      ],
      "properties": {
        "scan_id": { "type": "integer" },
        "deployment_id": { "type": "integer" },
        "repository_id": { "description": "", "type": "integer" },
        "repository_ref_id": { "description": "", "type": "integer" },
        "enabled_products": {
          "type": "array",
          "items": { "$ref": "#/definitions/product" }
        },
        "git_commit": { "$ref": "#/definitions/sha1" },
        "git_ref": { "type": [ "string", "null" ] }
      }
    },
    "contributor": {
      "description": "",
      "type": "object",
      "required": [ "commit_author_name", "commit_author_email" ],
      "properties": {
        "commit_author_name": { "type": "string" },
        "commit_author_email": { "type": "string" }
      }
    },
    "contribution": {
      "type": "object",
      "required": [ "commit_hash", "commit_timestamp", "contributor" ],
      "properties": {
        "commit_hash": { "type": "string" },
        "commit_timestamp": { "$ref": "#/definitions/datetime" },
        "contributor": { "$ref": "#/definitions/contributor" }
      }
    },
    "contributions": {
      "description": "",
      "type": "array",
      "items": { "$ref": "#/definitions/contribution" }
    },
    "ci_scan_results_response": {
      "description": "",
      "type": "object",
      "required": [ "errors" ],
      "properties": {
        "errors": {
          "type": "array",
          "items": { "$ref": "#/definitions/ci_scan_results_response_error" }
        },
        "task_id": { "type": "string" }
      }
    },
    "ci_scan_results_response_error": {
      "type": "object",
      "required": [ "message" ],
      "properties": { "message": { "type": "string" } }
    },
    "ci_scan_complete": {
      "type": "object",
      "required": [ "exit_code", "stats" ],
      "properties": {
        "exit_code": { "type": "integer" },
        "stats": { "$ref": "#/definitions/ci_scan_complete_stats" },
        "dependencies": {
          "description": "",
          "$ref": "#/definitions/ci_scan_dependencies"
        },
        "dependency_parser_errors": {
          "description": "",
          "type": "array",
          "items": { "$ref": "#/definitions/dependency_parser_error" }
        },
        "task_id": { "description": "", "type": "string" },
        "final_attempt": { "type": "boolean" }
      }
    },
    "ci_scan_complete_stats": {
      "type": "object",
      "required": [
        "findings", "errors", "total_time", "unsupported_exts",
        "lockfile_scan_info", "parse_rate"
      ],
      "properties": {
        "findings": { "type": "integer" },
        "errors": {
          "type": "array",
          "items": { "$ref": "#/definitions/cli_error" }
        },
        "total_time": { "type": "number" },
        "unsupported_exts": {
          "type": "object",
          "additionalProperties": { "type": "integer" }
        },
        "lockfile_scan_info": {
          "type": "object",
          "additionalProperties": { "type": "integer" }
        },
        "parse_rate": {
          "type": "object",
          "additionalProperties": { "$ref": "#/definitions/parsing_stats" }
        },
        "engine_requested": { "description": "", "type": "string" },
        "findings_by_product": {
          "description": "",
          "type": "object",
          "additionalProperties": { "type": "integer" }
        },
        "supply_chain_stats": {
          "description": "",
          "$ref": "#/definitions/supply_chain_stats"
        }
      }
    },
    "parsing_stats": {
      "type": "object",
      "required": [
        "targets_parsed", "num_targets", "bytes_parsed", "num_bytes"
      ],
      "properties": {
        "targets_parsed": { "type": "integer" },
        "num_targets": { "type": "integer" },
        "bytes_parsed": { "type": "integer" },
        "num_bytes": { "type": "integer" }
      }
    },
    "ci_scan_complete_response": {
      "description": "",
      "type": "object",
      "required": [ "success" ],
      "properties": {
        "success": { "type": "boolean" },
        "app_block_override": { "type": "boolean" },
        "app_block_reason": { "description": "", "type": "string" },
        "app_blocking_match_based_ids": {
          "description": "",
          "type": "array",
          "items": { "$ref": "#/definitions/match_based_id" }
        }
      }
    },
    "ci_scan_dependencies": {
      "type": "object",
      "additionalProperties": {
        "type": "array",
        "items": { "$ref": "#/definitions/found_dependency" }
      }
    },
    "dependency_parser_error": {
      "type": "object",
      "required": [ "path", "parser", "reason" ],
      "properties": {
        "path": { "$ref": "#/definitions/fpath" },
        "parser": { "$ref": "#/definitions/sca_parser_name" },
        "reason": { "type": "string" },
        "line": { "description": "", "type": "integer" },
        "col": { "type": "integer" },
        "text": { "type": "string" }
      }
    },
    "sca_parser_name": {
      "description": "",
      "oneOf": [
        { "const": "gemfile_lock" },
        { "const": "go_mod" },
        { "const": "go_sum" },
        { "const": "gradle_lockfile" },
        { "const": "gradle_build" },
        { "const": "jsondoc" },
        { "const": "pipfile" },
        { "const": "pnpm_lock" },
        { "const": "poetry_lock" },
        { "const": "pyproject_toml" },
        { "const": "requirements" },
        { "const": "yarn_1" },
        { "const": "yarn_2" },
        { "const": "pomtree" },
        { "const": "cargo" },
        { "const": "composer_lock" },
        { "const": "pubspec_lock" },
        { "const": "package_swift" },
        { "const": "podfile_lock" },
        { "const": "package_resolved" },
        { "const": "mix_lock" }
      ]
    },
    "supply_chain_stats": {
      "type": "object",
      "required": [ "subprojects_stats" ],
      "properties": {
        "subprojects_stats": {
          "type": "array",
          "items": { "$ref": "#/definitions/subproject_stats" }
        }
      }
    },
    "cli_output_subproject_info": {
      "description": "",
      "type": "object",
      "required": [ "dependency_sources", "resolved" ],
      "properties": {
        "dependency_sources": {
          "description": "",
          "type": "array",
          "items": { "$ref": "#/definitions/fpath" }
        },
        "resolved": { "description": "", "type": "boolean" },
        "unresolved_reason": {
          "description": "",
          "$ref": "#/definitions/unresolved_reason"
        },
        "resolved_stats": {
          "description": "",
          "$ref": "#/definitions/dependency_resolution_stats"
        }
      }
    },
    "subproject_stats": {
      "type": "object",
      "required": [ "subproject_id", "dependency_sources" ],
      "properties": {
        "subproject_id": { "description": "", "type": "string" },
        "dependency_sources": {
          "description": "",
          "type": "array",
          "items": { "$ref": "#/definitions/dependency_source_file" }
        },
        "resolved_stats": {
          "description": "",
          "$ref": "#/definitions/dependency_resolution_stats"
        },
        "unresolved_reason": {
          "description": "",
          "$ref": "#/definitions/unresolved_reason"
        },
        "errors": {
          "description": "",
          "type": "array",
          "items": { "$ref": "#/definitions/sca_error" }
        }
      }
    },
    "dependency_source_file": {
      "type": "object",
      "required": [ "kind", "path" ],
      "properties": {
        "kind": { "$ref": "#/definitions/dependency_source_file_kind" },
        "path": { "$ref": "#/definitions/fpath" }
      }
    },
    "dependency_source_file_kind": {
      "oneOf": [
        {
          "type": "array",
          "minItems": 2,
          "items": false,
          "prefixItems": [
            { "const": "Lockfile" },
            { "$ref": "#/definitions/lockfile_kind" }
          ]
        },
        {
          "type": "array",
          "minItems": 2,
          "items": false,
          "prefixItems": [
            { "const": "Manifest" },
            { "$ref": "#/definitions/manifest_kind" }
          ]
        }
      ]
    },
    "dependency_resolution_stats": {
      "type": "object",
      "required": [ "resolution_method", "dependency_count", "ecosystem" ],
      "properties": {
        "resolution_method": { "$ref": "#/definitions/resolution_method" },
        "dependency_count": { "type": "integer" },
        "ecosystem": { "$ref": "#/definitions/ecosystem" }
      }
    },
    "resolution_method": {
      "oneOf": [
        { "description": "", "const": "LockfileParsing" },
        { "description": "", "const": "DynamicResolution" }
      ]
    },
    "ci_scan_failure": {
      "description": "",
      "type": "object",
      "required": [ "exit_code", "stderr" ],
      "properties": {
        "exit_code": { "type": "integer" },
        "stderr": { "type": "string" }
      }
    },
    "deployment_config": {
      "description": "",
      "type": "object",
      "required": [ "id", "name" ],
      "properties": {
        "id": { "type": "integer" },
        "name": { "description": "", "type": "string" },
        "organization_id": { "type": "integer" },
        "display_name": { "description": "", "type": "string" },
        "scm_name": { "type": "string" },
        "slug": { "type": "string" },
        "source_type": { "description": "", "type": "string" },
        "default_user_role": { "description": "", "type": "string" },
        "has_autofix": { "type": "boolean" },
        "has_deepsemgrep": { "type": "boolean" },
        "has_triage_via_comment": { "type": "boolean" },
        "has_dependency_query": { "type": "boolean" }
      }
    },
    "has_features": {
      "description": "",
      "type": "object",
      "required": [],
      "properties": {
        "has_autofix": { "type": "boolean" },
        "has_deepsemgrep": { "type": "boolean" },
        "has_triage_via_comment": { "type": "boolean" },
        "has_dependency_query": { "type": "boolean" }
      }
    },
    "deployment_response": {
      "type": "object",
      "required": [ "deployment" ],
      "properties": {
        "deployment": { "$ref": "#/definitions/deployment_config" }
      }
    },
    "scan_config": {
      "description": "",
      "type": "object",
      "required": [
        "deployment_id", "deployment_name", "policy_names", "rule_config"
      ],
      "properties": {
        "deployment_id": { "type": "integer" },
        "deployment_name": { "type": "string" },
        "policy_names": {
          "description": "",
          "type": "array",
          "items": { "type": "string" }
        },
        "rule_config": { "description": "", "type": "string" },
        "autofix": { "type": "boolean" },
        "deepsemgrep": { "type": "boolean" },
        "dependency_query": { "type": "boolean" },
        "path_to_transitivity": { "description": "", "type": "boolean" },
        "scan_all_deps_in_diff_scan": {
          "description": "",
          "type": "boolean"
        },
        "symbol_analysis": { "description": "", "type": "boolean" },
        "transitive_reachability_enabled": { "type": "boolean" },
        "triage_ignored_syntactic_ids": {
          "type": "array",
          "items": { "type": "string" }
        },
        "triage_ignored_match_based_ids": {
          "description": "",
          "type": "array",
          "items": { "type": "string" }
        },
        "ignored_files": {
          "description": "",
          "type": "array",
          "items": { "type": "string" }
        },
        "enabled_products": {
          "description": "",
          "type": "array",
          "items": { "$ref": "#/definitions/product" }
        },
        "actions": {
          "description": "",
          "type": "array",
          "items": { "$ref": "#/definitions/action" }
        },
        "ci_config_from_cloud": {
          "description": "",
          "$ref": "#/definitions/ci_config_from_cloud"
        }
      }
    },
    "tr_cache_key": {
      "description": "",
      "type": "object",
      "required": [
        "rule_id", "rule_version", "engine_version", "package_url", "extra"
      ],
      "properties": {
        "rule_id": { "$ref": "#/definitions/rule_id" },
        "rule_version": { "description": "", "type": "string" },
        "engine_version": { "description": "", "type": "integer" },
        "package_url": { "description": "", "type": "string" },
        "extra": { "description": "", "type": "string" }
      }
    },
    "tr_cache_match_result": {
      "description": "",
      "type": "object",
      "required": [ "matches" ],
      "properties": {
        "matches": {
          "description": "",
          "type": "array",
          "items": { "$ref": "#/definitions/cli_match" }
        }
      }
    },
    "tr_query_cache_request": {
      "description": "",
      "type": "object",
      "required": [ "entries" ],
      "properties": {
        "entries": {
          "type": "array",
          "items": { "$ref": "#/definitions/tr_cache_key" }
        }
      }
    },
    "tr_query_cache_response": {
      "description": "",
      "type": "object",
      "required": [ "cached" ],
      "properties": {
        "cached": {
          "type": "array",
          "items": {
            "type": "array",
            "minItems": 2,
            "items": false,
            "prefixItems": [
              { "$ref": "#/definitions/tr_cache_key" },
              { "$ref": "#/definitions/tr_cache_match_result" }
            ]
          }
        }
      }
    },
    "tr_add_cache_request": {
      "description": "",
      "type": "object",
      "required": [ "new_entries" ],
      "properties": {
        "new_entries": {
          "type": "array",
          "items": {
            "type": "array",
            "minItems": 2,
            "items": false,
            "prefixItems": [
              { "$ref": "#/definitions/tr_cache_key" },
              { "$ref": "#/definitions/tr_cache_match_result" }
            ]
          }
        }
      }
    },
    "ci_config_from_cloud": {
      "description": "",
      "type": "object",
      "required": [ "repo_config" ],
      "properties": {
        "repo_config": { "$ref": "#/definitions/ci_config" },
        "org_config": { "$ref": "#/definitions/ci_config" },
        "dirs_config": {
          "description": "",
          "type": "array",
          "items": {
            "type": "array",
            "minItems": 2,
            "items": false,
            "prefixItems": [
              { "$ref": "#/definitions/fpath" },
              { "$ref": "#/definitions/ci_config" }
            ]
          }
        },
        "actions": {
          "type": "array",
          "items": { "$ref": "#/definitions/action" }
        }
      }
    },
    "ci_config": {
      "description": "",
      "type": "object",
      "required": [ "env", "enabled_products", "ignored_files" ],
      "properties": {
        "env": { "description": "", "$ref": "#/definitions/ci_env" },
        "enabled_products": {
          "type": "array",
          "items": { "$ref": "#/definitions/product" }
        },
        "ignored_files": {
          "description": "",
          "type": "array",
          "items": { "type": "string" }
        },
        "autofix": { "type": "boolean" },
        "deepsemgrep": { "type": "boolean" },
        "dependency_query": { "type": "boolean" },
        "path_to_transitivity": { "description": "", "type": "boolean" },
        "scan_all_deps_in_diff_scan": {
          "description": "",
          "type": "boolean"
        },
        "symbol_analysis": { "description": "", "type": "boolean" },
        "transitive_reachability_enabled": { "type": "boolean" }
      }
    },
    "ci_env": {
      "type": "object",
      "additionalProperties": { "type": "string" }
    },
    "core_output": {
      "type": "object",
      "required": [ "version", "results", "errors", "paths" ],
      "properties": {
        "version": { "$ref": "#/definitions/version" },
        "results": {
          "type": "array",
          "items": { "$ref": "#/definitions/core_match" }
        },
        "errors": {
          "description": "",
          "type": "array",
          "items": { "$ref": "#/definitions/core_error" }
        },
        "paths": {
          "description": "",
          "$ref": "#/definitions/scanned_and_skipped"
        },
        "time": { "description": "", "$ref": "#/definitions/profile" },
        "explanations": {
          "description": "",
          "type": "array",
          "items": { "$ref": "#/definitions/matching_explanation" }
        },
        "rules_by_engine": {
          "description": "",
          "type": "array",
          "items": { "$ref": "#/definitions/rule_id_and_engine_kind" }
        },
        "engine_requested": { "$ref": "#/definitions/engine_kind" },
        "interfile_languages_used": {
          "description": "",
          "type": "array",
          "items": { "type": "string" }
        },
        "skipped_rules": {
          "description": "",
          "type": "array",
          "items": { "$ref": "#/definitions/skipped_rule" }
        },
        "subprojects": {
          "description": "",
          "type": "array",
          "items": { "$ref": "#/definitions/cli_output_subproject_info" }
        },
        "mcp_scan_results": {
          "description": "",
          "$ref": "#/definitions/mcp_scan_results"
        },
        "profiling_results": {
          "description": "",
          "type": "array",
          "items": { "$ref": "#/definitions/profiling_entry" }
        },
        "symbol_analysis": {
          "description": "",
          "$ref": "#/definitions/symbol_analysis"
        }
      }
    },
    "core_output_extra": {
      "description": "",
      "type": "object",
      "required": [],
      "properties": {
        "symbol_analysis": {
          "description": "",
          "$ref": "#/definitions/symbol_analysis"
        }
      }
    },
    "core_match": {
      "description": "",
      "type": "object",
      "required": [ "check_id", "path", "start", "end", "extra" ],
      "properties": {
        "check_id": { "$ref": "#/definitions/rule_id" },
        "path": { "$ref": "#/definitions/fpath" },
        "start": { "$ref": "#/definitions/position" },
        "end": { "$ref": "#/definitions/position" },
        "extra": { "$ref": "#/definitions/core_match_extra" }
      }
    },
    "core_match_extra": {
      "description": "",
      "type": "object",
      "required": [ "metavars", "engine_kind", "is_ignored" ],
      "properties": {
        "metavars": { "$ref": "#/definitions/metavars" },
        "engine_kind": { "$ref": "#/definitions/engine_of_finding" },
        "is_ignored": { "type": "boolean" },
        "message": { "description": "", "type": "string" },
        "metadata": { "$ref": "#/definitions/raw_json" },
        "severity": { "$ref": "#/definitions/match_severity" },
        "fix": { "type": "string" },
        "dataflow_trace": { "$ref": "#/definitions/match_dataflow_trace" },
        "sca_match": { "$ref": "#/definitions/sca_match" },
        "validation_state": { "$ref": "#/definitions/validation_state" },
        "historical_info": { "$ref": "#/definitions/historical_info" },
        "extra_extra": {
          "description": "",
          "$ref": "#/definitions/raw_json"
        }
      }
    },
    "core_error": {
      "description": "",
      "type": "object",
      "required": [ "error_type", "severity", "message" ],
      "properties": {
        "error_type": { "$ref": "#/definitions/error_type" },
        "severity": { "$ref": "#/definitions/error_severity" },
        "message": { "type": "string" },
        "details": { "type": "string" },
        "location": { "$ref": "#/definitions/location" },
        "rule_id": { "$ref": "#/definitions/rule_id" }
      }
    },
    "project_root": {
      "description": "",
      "oneOf": [
        {
          "type": "array",
          "minItems": 2,
          "items": false,
          "prefixItems": [
            { "description": "", "const": "Filesystem" },
            { "type": "string" }
          ]
        },
        {
          "type": "array",
          "minItems": 2,
          "items": false,
          "prefixItems": [
            { "description": "", "const": "Git_remote" },
            { "type": "string" }
          ]
        }
      ]
    },
    "targeting_conf": {
      "description": "",
      "type": "object",
      "required": [
        "exclude", "max_target_bytes", "respect_gitignore",
        "respect_semgrepignore_files", "always_select_explicit_targets",
        "explicit_targets", "force_novcs_project", "exclude_minified_files"
      ],
      "properties": {
        "exclude": { "type": "array", "items": { "type": "string" } },
        "include_": { "type": "array", "items": { "type": "string" } },
        "max_target_bytes": { "type": "integer" },
        "respect_gitignore": { "type": "boolean" },
        "respect_semgrepignore_files": { "type": "boolean" },
        "semgrepignore_filename": { "type": "string" },
        "always_select_explicit_targets": { "type": "boolean" },
        "explicit_targets": {
          "description": "",
          "type": "array",
          "items": { "type": "string" }
        },
        "force_project_root": {
          "description": "",
          "$ref": "#/definitions/project_root"
        },
        "force_novcs_project": { "type": "boolean" },
        "exclude_minified_files": { "type": "boolean" },
        "baseline_commit": { "type": "string" }
      }
    },
    "analyzer": { "description": "", "type": "string" },
    "target": {
      "description": "",
      "oneOf": [
        {
          "type": "array",
          "minItems": 2,
          "items": false,
          "prefixItems": [
            { "const": "CodeTarget" },
            { "$ref": "#/definitions/code_target" }
          ]
        },
        {
          "type": "array",
          "minItems": 2,
          "items": false,
          "prefixItems": [
            { "const": "DependencySourceTarget" },
            { "$ref": "#/definitions/dependency_source" }
          ]
        }
      ]
    },
    "code_target": {
      "description": "",
      "type": "object",
      "required": [ "path", "analyzer", "products" ],
      "properties": {
        "path": { "$ref": "#/definitions/fppath" },
        "analyzer": { "description": "", "$ref": "#/definitions/analyzer" },
        "products": {
          "type": "array",
          "items": { "$ref": "#/definitions/product" }
        },
        "dependency_source": { "$ref": "#/definitions/dependency_source" }
      }
    },
    "scanning_roots": {
      "type": "object",
      "required": [ "root_paths", "targeting_conf" ],
      "properties": {
        "root_paths": {
          "type": "array",
          "items": { "$ref": "#/definitions/fpath" }
        },
        "targeting_conf": { "$ref": "#/definitions/targeting_conf" }
      }
    },
    "targets": {
      "description": "",
      "oneOf": [
        {
          "type": "array",
          "minItems": 2,
          "items": false,
          "prefixItems": [
            { "description": "", "const": "Scanning_roots" },
            { "$ref": "#/definitions/scanning_roots" }
          ]
        },
        {
          "type": "array",
          "minItems": 2,
          "items": false,
          "prefixItems": [
            { "description": "", "const": "Targets" },
            { "type": "array", "items": { "$ref": "#/definitions/target" } }
          ]
        }
      ]
    },
    "edit": {
      "type": "object",
      "required": [
        "path", "start_offset", "end_offset", "replacement_text"
      ],
      "properties": {
        "path": { "$ref": "#/definitions/fpath" },
        "start_offset": { "type": "integer" },
        "end_offset": { "type": "integer" },
        "replacement_text": { "type": "string" }
      }
    },
    "apply_fixes_params": {
      "type": "object",
      "required": [ "dryrun", "edits" ],
      "properties": {
        "dryrun": { "type": "boolean" },
        "edits": {
          "type": "array",
          "items": { "$ref": "#/definitions/edit" }
        }
      }
    },
    "apply_fixes_return": {
      "type": "object",
      "required": [ "modified_file_count", "fixed_lines" ],
      "properties": {
        "modified_file_count": { "description": "", "type": "integer" },
        "fixed_lines": {
          "description": "",
          "type": "array",
          "items": {
            "type": "array",
            "minItems": 2,
            "items": false,
            "prefixItems": [
              { "type": "integer" },
              { "type": "array", "items": { "type": "string" } }
            ]
          }
        }
      }
    },
    "sarif_format": {
      "type": "object",
      "required": [ "rules", "is_pro", "show_dataflow_traces" ],
      "properties": {
        "rules": { "description": "", "$ref": "#/definitions/fpath" },
        "is_pro": { "type": "boolean" },
        "show_dataflow_traces": { "type": "boolean" }
      }
    },
    "output_format": {
      "oneOf": [
        { "const": "Text" },
        { "const": "Json" },
        { "const": "Emacs" },
        { "const": "Vim" },
        { "const": "Sarif" },
        { "const": "Gitlab_sast" },
        { "const": "Gitlab_secrets" },
        { "const": "Junit_xml" },
        { "description": "", "const": "Files_with_matches" },
        { "description": "", "const": "Incremental" }
      ]
    },
    "format_context": {
      "type": "object",
      "required": [ "is_ci_invocation", "is_logged_in", "is_using_registry" ],
      "properties": {
        "is_ci_invocation": { "type": "boolean" },
        "is_logged_in": { "type": "boolean" },
        "is_using_registry": { "type": "boolean" }
      }
    },
    "dump_rule_partitions_params": {
      "type": "object",
      "required": [ "rules", "n_partitions", "output_dir" ],
      "properties": {
        "rules": { "$ref": "#/definitions/raw_json" },
        "n_partitions": { "type": "integer" },
        "output_dir": { "$ref": "#/definitions/fpath" },
        "strategy": { "type": "string" }
      }
    },
    "lockfile_kind": {
      "oneOf": [
        { "const": "PipRequirementsTxt" },
        { "const": "PoetryLock" },
        { "const": "PipfileLock" },
        { "const": "UvLock" },
        { "const": "NpmPackageLockJson" },
        { "const": "YarnLock" },
        { "const": "PnpmLock" },
        { "const": "BunLock" },
        {
          "description": "Bun's deprecated binary bun.lockb format",
          "const": "BunBinaryLock"
        },
        { "const": "GemfileLock" },
        { "const": "GoMod" },
        { "const": "CargoLock" },
        { "description": "", "const": "MavenDepTree" },
        { "const": "GradleLockfile" },
        { "const": "ComposerLock" },
        { "const": "NugetPackagesLockJson" },
        { "const": "PubspecLock" },
        { "description": "", "const": "SwiftPackageResolved" },
        { "const": "PodfileLock" },
        { "const": "MixLock" },
        { "const": "ConanLock" },
        { "const": "OpamLocked" }
      ]
    },
    "manifest_kind": {
      "oneOf": [
        { "description": "", "const": "RequirementsIn" },
        { "description": "", "const": "SetupPy" },
        { "description": "", "const": "PackageJson" },
        { "description": "", "const": "Gemfile" },
        { "description": "", "const": "GoMod" },
        { "description": "", "const": "CargoToml" },
        { "description": "", "const": "PomXml" },
        { "description": "", "const": "BuildGradle" },
        { "description": "", "const": "BuildGradleKts" },
        { "description": "", "const": "SettingsGradle" },
        { "description": "", "const": "ComposerJson" },
        { "description": "", "const": "NugetManifestJson" },
        { "description": "", "const": "PubspecYaml" },
        { "description": "", "const": "PackageSwift" },
        { "description": "", "const": "Podfile" },
        { "description": "", "const": "MixExs" },
        { "description": "", "const": "Pipfile" },
        { "description": "", "const": "PyprojectToml" },
        { "description": "", "const": "ConanFileTxt" },
        { "description": "", "const": "ConanFilePy" },
        { "description": "", "const": "Csproj" },
        { "description": "", "const": "OpamFile" },
        { "description": "", "const": "BuildSbt" }
      ]
    },
    "manifest": {
      "type": "object",
      "required": [ "kind", "path" ],
      "properties": {
        "kind": { "$ref": "#/definitions/manifest_kind" },
        "path": { "$ref": "#/definitions/fpath" }
      }
    },
    "lockfile": {
      "type": "object",
      "required": [ "kind", "path" ],
      "properties": {
        "kind": { "$ref": "#/definitions/lockfile_kind" },
        "path": { "$ref": "#/definitions/fpath" }
      }
    },
    "dependency_source": {
      "oneOf": [
        {
          "type": "array",
          "minItems": 2,
          "items": false,
          "prefixItems": [
            { "const": "ManifestOnly" }, { "$ref": "#/definitions/manifest" }
          ]
        },
        {
          "type": "array",
          "minItems": 2,
          "items": false,
          "prefixItems": [
            { "const": "LockfileOnly" }, { "$ref": "#/definitions/lockfile" }
          ]
        },
        {
          "type": "array",
          "minItems": 2,
          "items": false,
          "prefixItems": [
            { "const": "ManifestLockfile" },
            {
              "type": "array",
              "minItems": 2,
              "items": false,
              "prefixItems": [
                { "$ref": "#/definitions/manifest" },
                { "$ref": "#/definitions/lockfile" }
              ]
            }
          ]
        },
        {
          "type": "array",
          "minItems": 2,
          "items": false,
          "prefixItems": [
            { "description": "", "const": "MultiLockfile" },
            {
              "type": "array",
              "items": { "$ref": "#/definitions/dependency_source" }
            }
          ]
        }
      ]
    },
    "resolution_error_kind": {
      "oneOf": [
        { "const": "UnsupportedManifest" },
        {
          "type": "array",
          "minItems": 2,
          "items": false,
          "prefixItems": [
            { "const": "MissingRequirement" }, { "type": "string" }
          ]
        },
        {
          "type": "array",
          "minItems": 2,
          "items": false,
          "prefixItems": [
            { "const": "ResolutionCmdFailed" },
            { "$ref": "#/definitions/resolution_cmd_failed" }
          ]
        },
        {
          "type": "array",
          "minItems": 2,
          "items": false,
          "prefixItems": [
            { "description": "", "const": "ParseDependenciesFailed" },
            { "type": "string" }
          ]
        },
        {
          "type": "array",
          "minItems": 2,
          "items": false,
          "prefixItems": [
            { "description": "", "const": "ScaParseError" },
            { "$ref": "#/definitions/sca_parser_name" }
          ]
        }
      ]
    },
    "resolution_cmd_failed": {
      "type": "object",
      "required": [ "command", "message" ],
      "properties": {
        "command": { "type": "string" },
        "message": { "type": "string" }
      }
    },
    "sca_resolution_error": {
      "description": "",
      "type": "object",
      "required": [ "type_", "dependency_source_file" ],
      "properties": {
        "type_": { "$ref": "#/definitions/resolution_error_kind" },
        "dependency_source_file": { "$ref": "#/definitions/fpath" }
      }
    },
    "sca_error": {
      "oneOf": [
        {
          "type": "array",
          "minItems": 2,
          "items": false,
          "prefixItems": [
            { "const": "SCAParse" },
            { "$ref": "#/definitions/dependency_parser_error" }
          ]
        },
        {
          "type": "array",
          "minItems": 2,
          "items": false,
          "prefixItems": [
            { "const": "SCAResol" },
            { "$ref": "#/definitions/sca_resolution_error" }
          ]
        }
      ]
    },
    "subproject": {
      "description": "",
      "type": "object",
      "required": [ "root_dir", "ecosystem", "dependency_source" ],
      "properties": {
        "root_dir": { "$ref": "#/definitions/fpath" },
        "ecosystem": {
          "description": "",
          "oneOf": [
            {
              "type": "array",
              "minItems": 2,
              "items": false,
              "prefixItems": [
                { "const": "Some" }, { "$ref": "#/definitions/ecosystem" }
              ]
            },
            { "const": "None" }
          ]
        },
        "dependency_source": { "$ref": "#/definitions/dependency_source" }
      }
    },
    "resolved_subproject": {
      "description": "",
      "type": "object",
      "required": [
        "info", "resolution_method", "ecosystem", "resolved_dependencies",
        "errors"
      ],
      "properties": {
        "info": { "$ref": "#/definitions/subproject" },
        "resolution_method": {
          "description": "",
          "$ref": "#/definitions/resolution_method"
        },
        "ecosystem": { "description": "", "$ref": "#/definitions/ecosystem" },
        "resolved_dependencies": {
          "description": "",
          "type": "array",
          "items": {
            "type": "array",
            "minItems": 2,
            "items": false,
            "prefixItems": [
              { "$ref": "#/definitions/dependency_child" },
              {
                "type": "array",
                "items": { "$ref": "#/definitions/resolved_dependency" }
              }
            ]
          }
        },
        "errors": {
          "type": "array",
          "items": { "$ref": "#/definitions/sca_error" }
        }
      }
    },
    "resolved_dependency": {
      "type": "array",
      "minItems": 2,
      "items": false,
      "prefixItems": [
        { "$ref": "#/definitions/found_dependency" },
        {
          "oneOf": [
            {
              "type": "array",
              "minItems": 2,
              "items": false,
              "prefixItems": [
                { "const": "Some" },
                { "$ref": "#/definitions/downloaded_dependency" }
              ]
            },
            { "const": "None" }
          ]
        }
      ]
    },
    "downloaded_dependency": {
      "description": "",
      "type": "object",
      "required": [ "source_paths" ],
      "properties": {
        "source_paths": {
          "type": "array",
          "items": { "$ref": "#/definitions/fpath" }
        }
      }
    },
    "unresolved_reason": {
      "oneOf": [
        { "description": "", "const": "failed" },
        { "description": "", "const": "skipped" },
        { "description": "", "const": "unsupported" },
        { "description": "", "const": "disabled" }
      ]
    },
    "unresolved_subproject": {
      "type": "object",
      "required": [ "info", "reason", "errors" ],
      "properties": {
        "info": { "$ref": "#/definitions/subproject" },
        "reason": { "$ref": "#/definitions/unresolved_reason" },
        "errors": {
          "description": "",
          "type": "array",
          "items": { "$ref": "#/definitions/sca_error" }
        }
      }
    },
    "resolve_dependencies_params": {
      "type": "object",
      "required": [
        "dependency_sources", "download_dependency_source_code",
        "allow_local_builds"
      ],
      "properties": {
        "dependency_sources": {
          "type": "array",
          "items": { "$ref": "#/definitions/dependency_source" }
        },
        "download_dependency_source_code": { "type": "boolean" },
        "allow_local_builds": { "description": "", "type": "boolean" }
      }
    },
    "resolution_result": {
      "oneOf": [
        {
          "type": "array",
          "minItems": 2,
          "items": false,
          "prefixItems": [
            { "const": "ResolutionOk" },
            {
              "type": "array",
              "minItems": 2,
              "items": false,
              "prefixItems": [
                {
                  "type": "array",
                  "items": { "$ref": "#/definitions/resolved_dependency" }
                },
                {
                  "type": "array",
                  "items": { "$ref": "#/definitions/resolution_error_kind" }
                }
              ]
            }
          ]
        },
        {
          "type": "array",
          "minItems": 2,
          "items": false,
          "prefixItems": [
            { "const": "ResolutionError" },
            {
              "type": "array",
              "items": { "$ref": "#/definitions/resolution_error_kind" }
            }
          ]
        }
      ]
    },
    "transitive_finding": {
      "type": "object",
      "required": [ "m" ],
      "properties": {
        "m": { "description": "", "$ref": "#/definitions/core_match" }
      }
    },
    "transitive_reachability_filter_params": {
      "type": "object",
      "required": [
        "rules_path", "findings", "dependencies", "write_to_cache"
      ],
      "properties": {
        "rules_path": { "$ref": "#/definitions/fpath" },
        "findings": {
          "type": "array",
          "items": { "$ref": "#/definitions/transitive_finding" }
        },
        "dependencies": {
          "type": "array",
          "items": { "$ref": "#/definitions/resolved_dependency" }
        },
        "write_to_cache": { "type": "boolean" }
      }
    },
    "symbol_analysis_upload_response": {
      "type": "object",
      "required": [ "upload_url" ],
      "properties": {
        "upload_url": { "description": "", "$ref": "#/definitions/uri" }
      }
    },
    "symbol": {
      "description": "",
      "type": "object",
      "required": [ "fqn" ],
      "properties": {
        "fqn": { "type": "array", "items": { "type": "string" } }
      }
    },
    "symbol_usage": {
      "description": "",
      "type": "object",
      "required": [ "symbol", "locs" ],
      "properties": {
        "symbol": { "$ref": "#/definitions/symbol" },
        "locs": {
          "type": "array",
          "items": { "$ref": "#/definitions/location" }
        }
      }
    },
    "symbol_analysis": {
      "type": "array",
      "items": { "$ref": "#/definitions/symbol_usage" }
    },
    "function_call": {
      "oneOf": [
        { "const": "CallContributions" },
        {
          "type": "array",
          "minItems": 2,
          "items": false,
          "prefixItems": [
            { "const": "CallApplyFixes" },
            { "$ref": "#/definitions/apply_fixes_params" }
          ]
        },
        {
          "type": "array",
          "minItems": 2,
          "items": false,
          "prefixItems": [
            { "const": "CallFormatter" },
            {
              "type": "array",
              "minItems": 3,
              "items": false,
              "prefixItems": [
                { "$ref": "#/definitions/output_format" },
                { "$ref": "#/definitions/format_context" },
                { "$ref": "#/definitions/cli_output" }
              ]
            }
          ]
        },
        {
          "type": "array",
          "minItems": 2,
          "items": false,
          "prefixItems": [
            { "description": "", "const": "CallSarifFormat" },
            {
              "type": "array",
              "minItems": 3,
              "items": false,
              "prefixItems": [
                { "$ref": "#/definitions/sarif_format" },
                { "$ref": "#/definitions/format_context" },
                { "$ref": "#/definitions/cli_output" }
              ]
            }
          ]
        },
        {
          "type": "array",
          "minItems": 2,
          "items": false,
          "prefixItems": [
            { "description": "", "const": "CallValidate" },
            { "$ref": "#/definitions/fpath" }
          ]
        },
        {
          "type": "array",
          "minItems": 2,
          "items": false,
          "prefixItems": [
            { "const": "CallResolveDependencies" },
            { "$ref": "#/definitions/resolve_dependencies_params" }
          ]
        },
        {
          "type": "array",
          "minItems": 2,
          "items": false,
          "prefixItems": [
            { "const": "CallUploadSymbolAnalysis" },
            {
              "type": "array",
              "minItems": 3,
              "items": false,
              "prefixItems": [
                { "type": "string" },
                { "type": "integer" },
                { "$ref": "#/definitions/symbol_analysis" }
              ]
            }
          ]
        },
        {
          "type": "array",
          "minItems": 2,
          "items": false,
          "prefixItems": [
            { "const": "CallDumpRulePartitions" },
            { "$ref": "#/definitions/dump_rule_partitions_params" }
          ]
        },
        {
          "type": "array",
          "minItems": 2,
          "items": false,
          "prefixItems": [
            { "const": "CallGetTargets" },
            { "$ref": "#/definitions/scanning_roots" }
          ]
        },
        {
          "type": "array",
          "minItems": 2,
          "items": false,
          "prefixItems": [
            {
              "description": "",
              "const": "CallTransitiveReachabilityFilter"
            },
            { "$ref": "#/definitions/transitive_reachability_filter_params" }
          ]
        },
        {
          "type": "array",
          "minItems": 2,
          "items": false,
          "prefixItems": [
            { "const": "CallMatchSubprojects" },
            { "type": "array", "items": { "$ref": "#/definitions/fpath" } }
          ]
        }
      ]
    },
    "function_return": {
      "oneOf": [
        {
          "type": "array",
          "minItems": 2,
          "items": false,
          "prefixItems": [ { "const": "RetError" }, { "type": "string" } ]
        },
        {
          "type": "array",
          "minItems": 2,
          "items": false,
          "prefixItems": [
            { "const": "RetApplyFixes" },
            { "$ref": "#/definitions/apply_fixes_return" }
          ]
        },
        {
          "type": "array",
          "minItems": 2,
          "items": false,
          "prefixItems": [
            { "const": "RetContributions" },
            { "$ref": "#/definitions/contributions" }
          ]
        },
        {
          "type": "array",
          "minItems": 2,
          "items": false,
          "prefixItems": [
            { "const": "RetFormatter" }, { "type": "string" }
          ]
        },
        {
          "type": "array",
          "minItems": 2,
          "items": false,
          "prefixItems": [
            { "const": "RetSarifFormat" }, { "type": "string" }
          ]
        },
        {
          "type": "array",
          "minItems": 2,
          "items": false,
          "prefixItems": [
            { "description": "", "const": "RetValidate" },
            {
              "oneOf": [
                {
                  "type": "array",
                  "minItems": 2,
                  "items": false,
                  "prefixItems": [
                    { "const": "Some" },
                    { "$ref": "#/definitions/core_error" }
                  ]
                },
                { "const": "None" }
              ]
            }
          ]
        },
        {
          "type": "array",
          "minItems": 2,
          "items": false,
          "prefixItems": [
            { "const": "RetResolveDependencies" },
            {
              "type": "array",
              "items": {
                "type": "array",
                "minItems": 2,
                "items": false,
                "prefixItems": [
                  { "$ref": "#/definitions/dependency_source" },
                  { "$ref": "#/definitions/resolution_result" }
                ]
              }
            }
          ]
        },
        {
          "type": "array",
          "minItems": 2,
          "items": false,
          "prefixItems": [
            { "description": "", "const": "RetUploadSymbolAnalysis" },
            { "type": "string" }
          ]
        },
        {
          "type": "array",
          "minItems": 2,
          "items": false,
          "prefixItems": [
            { "const": "RetDumpRulePartitions" }, { "type": "boolean" }
          ]
        },
        {
          "type": "array",
          "minItems": 2,
          "items": false,
          "prefixItems": [
            { "const": "RetTransitiveReachabilityFilter" },
            {
              "type": "array",
              "items": { "$ref": "#/definitions/transitive_finding" }
            }
          ]
        },
        {
          "type": "array",
          "minItems": 2,
          "items": false,
          "prefixItems": [
            { "const": "RetGetTargets" },
            { "$ref": "#/definitions/target_discovery_result" }
          ]
        },
        {
          "type": "array",
          "minItems": 2,
          "items": false,
          "prefixItems": [
            { "const": "RetMatchSubprojects" },
            {
              "type": "array",
              "items": { "$ref": "#/definitions/subproject" }
            }
          ]
        }
      ]
    },
    "function_result": {
      "type": "object",
      "required": [ "function_return", "profiling_results" ],
      "properties": {
        "function_return": { "$ref": "#/definitions/function_return" },
        "profiling_results": {
          "type": "array",
          "items": { "$ref": "#/definitions/profiling_entry" }
        }
      }
    },
    "partial_scan_result": {
      "description": "",
      "oneOf": [
        {
          "type": "array",
          "minItems": 2,
          "items": false,
          "prefixItems": [
            { "const": "PartialScanOk" },
            {
              "type": "array",
              "minItems": 2,
              "items": false,
              "prefixItems": [
                { "$ref": "#/definitions/ci_scan_results" },
                { "$ref": "#/definitions/ci_scan_complete" }
              ]
            }
          ]
        },
        {
          "type": "array",
          "minItems": 2,
          "items": false,
          "prefixItems": [
            { "const": "PartialScanError" },
            { "$ref": "#/definitions/ci_scan_failure" }
          ]
        }
      ]
    },
    "diff_file": {
      "description": "",
      "type": "object",
      "required": [ "filename", "diffs", "url" ],
      "properties": {
        "filename": { "$ref": "#/definitions/fpath" },
        "diffs": {
          "description": "",
          "type": "array",
          "items": { "type": "string" }
        },
        "url": { "description": "", "type": "string" }
      }
    },
    "diff_files": {
      "type": "object",
      "required": [ "cve_diffs" ],
      "properties": {
        "cve_diffs": {
          "type": "array",
          "items": { "$ref": "#/definitions/diff_file" }
        }
      }
    },
    "profiling_entry": {
      "description": "",
      "type": "object",
      "required": [ "name", "total_time", "count" ],
      "properties": {
        "name": { "type": "string" },
        "total_time": { "description": "", "type": "number" },
        "count": { "description": "", "type": "integer" }
      }
    }
  }
}
